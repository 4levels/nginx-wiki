#
msgid ""
msgstr ""
"Project-Id-Version: Nginx Wiki 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-07-13 11:11+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/modules/lua.rst:2
msgid "Lua"
msgstr ""

#: ../../source/modules/lua.rst:5
msgid "Name"
msgstr ""

#: ../../source/modules/lua.rst:6
msgid "**ngx_lua** - Embed the power of Lua into Nginx"
msgstr ""

#: ../../source/modules/lua.rst:8
msgid ""
"*This module is not distributed with the Nginx source.* See the "
"`installation instructions <lua.installation_>`_."
msgstr ""

#: ../../source/modules/lua.rst:12
msgid "Status"
msgstr ""

#: ../../source/modules/lua.rst:13
msgid "Production ready."
msgstr ""

#: ../../source/modules/lua.rst:18
msgid "Version"
msgstr ""

#: ../../source/modules/lua.rst:19
msgid ""
"This document describes ngx_lua :github:`v0.9.15 <openresty/lua-nginx-"
"module/tags>` released on February 18, 2015."
msgstr ""

#: ../../source/modules/lua.rst:24
msgid "Synopsis"
msgstr ""

#: ../../source/modules/lua.rst:197
msgid "Description"
msgstr ""

#: ../../source/modules/lua.rst:198
msgid ""
"This module embeds Lua, via the standard Lua 5.1 interpreter or `LuaJIT "
"2.0/2.1 <http://luajit.org/luajit.html>`_, into Nginx and by leveraging "
"Nginx's subrequests, allows the integration of the powerful Lua threads (Lua"
" coroutines) into the Nginx event model."
msgstr ""

#: ../../source/modules/lua.rst:200
msgid ""
"Unlike `Apache's mod_lua "
"<https://httpd.apache.org/docs/trunk/mod/mod_lua.html>`_ and `Lighttpd's "
"mod_magnet <http://redmine.lighttpd.net/projects/1/wiki/Docs_ModMagnet>`_, "
"Lua code executed using this module can be *100% non-blocking* on network "
"traffic as long as the `Nginx API for Lua`_ provided by this module is used "
"to handle requests to upstream services such as MySQL, PostgreSQL, "
"Memcached, Redis, or upstream HTTP web services."
msgstr ""

#: ../../source/modules/lua.rst:202
msgid ""
"At least the following Lua libraries and Nginx modules can be used with this"
" ngx_lua module:"
msgstr ""

#: ../../source/modules/lua.rst:204
msgid ":github:`lua-resty-memcached <openresty/lua-resty-memcached>`"
msgstr ""

#: ../../source/modules/lua.rst:205
msgid ":github:`lua-resty-mysql <openresty/lua-resty-mysql>`"
msgstr ""

#: ../../source/modules/lua.rst:206
msgid ":github:`lua-resty-redis <openresty/lua-resty-redis>`"
msgstr ""

#: ../../source/modules/lua.rst:207
msgid ":github:`lua-resty-dns <openresty/lua-resty-dns>`"
msgstr ""

#: ../../source/modules/lua.rst:208
msgid ":github:`lua-resty-upload <openresty/lua-resty-upload>`"
msgstr ""

#: ../../source/modules/lua.rst:209
msgid ":github:`lua-resty-websocket <openresty/lua-resty-websocket>`"
msgstr ""

#: ../../source/modules/lua.rst:210
msgid ":github:`lua-resty-lock <openresty/lua-resty-lock>`"
msgstr ""

#: ../../source/modules/lua.rst:211
msgid ":github:`lua-resty-string <openresty/lua-resty-string>`"
msgstr ""

#: ../../source/modules/lua.rst:212
msgid ":doc:`ngx_memc <memc>`"
msgstr ""

#: ../../source/modules/lua.rst:213
msgid ":github:`ngx_postgres <FRiCKLE/ngx_postgres>`"
msgstr ""

#: ../../source/modules/lua.rst:214
msgid ":doc:`ngx_redis2 <redis2>`"
msgstr ""

#: ../../source/modules/lua.rst:215
msgid ":doc:`ngx_redis <redis>`"
msgstr ""

#: ../../source/modules/lua.rst:216
msgid "`ngx_proxy <|HttpProxyModule|>`_"
msgstr ""

#: ../../source/modules/lua.rst:217
msgid "`ngx_fastcgi <|HttpFastcgiModule|>`_"
msgstr ""

#: ../../source/modules/lua.rst:219
msgid ""
"Almost all the Nginx modules can be used with this ngx_lua module by means "
"of `ngx.location.capture`_ or `ngx.location.capture_multi`_ but it is "
"recommended to use those ``lua-resty-*`` libraries instead of creating "
"subrequests to access the Nginx upstream modules because the former is "
"usually much more flexible and memory-efficient."
msgstr ""

#: ../../source/modules/lua.rst:221
msgid ""
"The Lua interpreter or LuaJIT instance is shared across all the requests in "
"a single nginx worker process but request contexts are segregated using "
"lightweight Lua coroutines."
msgstr ""

#: ../../source/modules/lua.rst:223
msgid ""
"Loaded Lua modules persist in the nginx worker process level resulting in a "
"small memory footprint in Lua even when under heavy loads."
msgstr ""

#: ../../source/modules/lua.rst:228
msgid "Typical Uses"
msgstr ""

#: ../../source/modules/lua.rst:229
msgid "Just to name a few:"
msgstr ""

#: ../../source/modules/lua.rst:231
msgid ""
"Mashup'ing and processing outputs of various nginx upstream outputs (proxy, "
"drizzle, postgres, redis, memcached, and etc) in Lua,"
msgstr ""

#: ../../source/modules/lua.rst:232
msgid ""
"doing arbitrarily complex access control and security checks in Lua before "
"requests actually reach the upstream backends,"
msgstr ""

#: ../../source/modules/lua.rst:233
msgid "manipulating response headers in an arbitrary way (by Lua)"
msgstr ""

#: ../../source/modules/lua.rst:234
msgid ""
"fetching backend information from external storage backends (like redis, "
"memcached, mysql, postgresql) and use that information to choose which "
"upstream backend to access on-the-fly,"
msgstr ""

#: ../../source/modules/lua.rst:235
msgid ""
"coding up arbitrarily complex web applications in a content handler using "
"synchronous but still non-blocking access to the database backends and other"
" storage,"
msgstr ""

#: ../../source/modules/lua.rst:236
msgid "doing very complex URL dispatch in Lua at rewrite phase,"
msgstr ""

#: ../../source/modules/lua.rst:237
msgid ""
"using Lua to implement advanced caching mechanism for Nginx's subrequests "
"and arbitrary locations."
msgstr ""

#: ../../source/modules/lua.rst:239
msgid ""
"The possibilities are unlimited as the module allows bringing together "
"various elements within Nginx as well as exposing the power of the Lua "
"language to the user. The module provides the full flexibility of scripting "
"while offering performance levels comparable with native C language programs"
" both in terms of CPU time as well as memory footprint. This is particularly"
" the case when LuaJIT 2.x is enabled."
msgstr ""

#: ../../source/modules/lua.rst:241
msgid ""
"Other scripting language implementations typically struggle to match this "
"performance level."
msgstr ""

#: ../../source/modules/lua.rst:243
msgid ""
"The Lua state (Lua VM instance) is shared across all the requests handled by"
" a single nginx worker process to minimize memory use."
msgstr ""

#: ../../source/modules/lua.rst:250
msgid "Nginx Compatibility"
msgstr ""

#: ../../source/modules/lua.rst:252
msgid "The latest module is compatible with the following versions of Nginx:"
msgstr ""

#: ../../source/modules/lua.rst:254
msgid "**1.7.x** (last tested: 1.7.10)"
msgstr ""

#: ../../source/modules/lua.rst:255
msgid "**1.6.x**"
msgstr ""

#: ../../source/modules/lua.rst:256
msgid "**1.5.x** (last tested: 1.5.12)"
msgstr ""

#: ../../source/modules/lua.rst:257
msgid "**1.4.x** (last tested: 1.4.4)"
msgstr ""

#: ../../source/modules/lua.rst:258
msgid "**1.3.x** (last tested: 1.3.11)"
msgstr ""

#: ../../source/modules/lua.rst:259
msgid "**1.2.x** (last tested: 1.2.9)"
msgstr ""

#: ../../source/modules/lua.rst:260
msgid "**1.1.x** (last tested: 1.1.5)"
msgstr ""

#: ../../source/modules/lua.rst:261
msgid "**1.0.x** (last tested: 1.0.15)"
msgstr ""

#: ../../source/modules/lua.rst:262
msgid "**0.9.x** (last tested: 0.9.4)"
msgstr ""

#: ../../source/modules/lua.rst:263
msgid "**0.8.x** >= 0.8.54 (last tested: 0.8.54)"
msgstr ""

#: ../../source/modules/lua.rst:270
msgid "Installation"
msgstr ""

#: ../../source/modules/lua.rst:271
msgid ""
"It is highly recommended to use the `ngx_openresty bundle "
"<http://openresty.org>`__ that bundles Nginx, ngx_lua,  LuaJIT 2.0/2.1 (or "
"the optional standard Lua 5.1 interpreter), as well as a package of powerful"
" companion Nginx modules. The basic installation step is a simple command:"
msgstr ""

#: ../../source/modules/lua.rst:279
msgid "Alternatively, ngx_lua can be manually compiled into Nginx:"
msgstr ""

#: ../../source/modules/lua.rst:281
msgid ""
"Install LuaJIT 2.0 or 2.1 (recommended) or Lua 5.1 (Lua 5.2 is *not*  "
"supported yet). LuaJIT can be downloaded from the `the LuaJIT project "
"website <http://luajit.org/download.html>`_ and Lua 5.1, from the `Lua "
"project website <http://www.lua.org/>`_. Some distribution package managers "
"also distribute LuajIT and/or Lua."
msgstr ""

#: ../../source/modules/lua.rst:282
msgid ""
"Download the latest version of the ngx_devel_kit (NDK) module :github:`here "
"<simpl/ngx_devel_kit/tags>`"
msgstr ""

#: ../../source/modules/lua.rst:283
msgid ""
"Download the latest version of ngx_lua :github:`here <openresty/lua-nginx-"
"module/tags>`"
msgstr ""

#: ../../source/modules/lua.rst:284
msgid "Download the latest version of Nginx `here <http://nginx.org/>`__."
msgstr ""

#: ../../source/modules/lua.rst:286
msgid "`Nginx Compatability <lua.compatibility_>`_"
msgstr ""

#: ../../source/modules/lua.rst:288
msgid "Build the source with this module:"
msgstr ""

#: ../../source/modules/lua.rst:319
msgid "C Macro Configurations"
msgstr ""

#: ../../source/modules/lua.rst:320
msgid ""
"While building this module either via OpenResty or with the NGINX core, you "
"can define the following C macros via the C compiler options:"
msgstr ""

#: ../../source/modules/lua.rst:322
msgid "``NGX_LUA_USE_ASSERT``"
msgstr ""

#: ../../source/modules/lua.rst:323
msgid ""
"When defined, will enable assertions in the ngx_lua C code base. Recommended"
" for debugging or testing builds. It can introduce some (small) runtime "
"overhead when enabled. This macro was first introduced in the ``v0.9.10`` "
"release."
msgstr ""

#: ../../source/modules/lua.rst:324
msgid "``NGX_LUA_ABORT_AT_PANIC``"
msgstr ""

#: ../../source/modules/lua.rst:325
msgid ""
"When the Lua/LuaJIT VM panics, ngx_lua will instruct the current nginx "
"worker process to quit gracefully by default. By specifying this C macro, "
"ngx_lua will abort the current nginx worker process (which usually result in"
" a core dump file) immediately. This option is useful for debugging VM "
"panics. This option was first introduced in the ``v0.9.8`` release."
msgstr ""

#: ../../source/modules/lua.rst:327
msgid "``NGX_LUA_NO_FFI_API``"
msgstr ""

#: ../../source/modules/lua.rst:327
msgid ""
"Excludes pure C API functions for FFI-based Lua API for NGINX (as required "
"by :github:`lua-resty-core <openresty/lua-resty-core#readme>` for example). "
"Enabling this macro can make the resulting binary code size smaller."
msgstr ""

#: ../../source/modules/lua.rst:329
msgid ""
"To enable one or more of these macros, just pass extra C compiler options to"
" the ``./configure`` script of either NGINX or OpenResty. For instance,"
msgstr ""

#: ../../source/modules/lua.rst:337
msgid "Installation on Ubuntu 11.10"
msgstr ""

#: ../../source/modules/lua.rst:338
msgid ""
"Note that it is recommended to use LuaJIT 2.0 or LuaJIT 2.1 instead of the "
"standard Lua 5.1 interpreter wherever possible."
msgstr ""

#: ../../source/modules/lua.rst:340
msgid ""
"If the standard Lua 5.1 interpreter is required however, run the following "
"command to install it from the Ubuntu repository:"
msgstr ""

#: ../../source/modules/lua.rst:347
msgid "Everything should be installed correctly, except for one small tweak."
msgstr ""

#: ../../source/modules/lua.rst:349
msgid ""
"Library name ``liblua.so`` has been changed in liblua5.1 package, it only "
"comes with ``liblua5.1.so``, which needs to be symlinked to ``/usr/lib`` so "
"it could be found during the configuration process."
msgstr ""

#: ../../source/modules/lua.rst:360
msgid "Community"
msgstr ""

#: ../../source/modules/lua.rst:363
msgid "English Mailing List"
msgstr ""

#: ../../source/modules/lua.rst:364
msgid ""
"The `openresty-en <https://groups.google.com/group/openresty-en>`_ mailing "
"list is for English speakers."
msgstr ""

#: ../../source/modules/lua.rst:368
msgid "Chinese Mailing List"
msgstr ""

#: ../../source/modules/lua.rst:369
msgid ""
"The `openresty <https://groups.google.com/group/openresty>`_ mailing list is"
" for Chinese speakers."
msgstr ""

#: ../../source/modules/lua.rst:374
msgid "Source Repository"
msgstr ""

#: ../../source/modules/lua.rst:375
msgid ""
"The source repository of this project is hosted on GitHub at "
":github:`openresty/lua-nginx-module <openresty/lua-nginx-module>`"
msgstr ""

#: ../../source/modules/lua.rst:380
msgid "Bugs and Patches"
msgstr ""

#: ../../source/modules/lua.rst:381
msgid "Please submit bug reports, wishlists, or patches by"
msgstr ""

#: ../../source/modules/lua.rst:383
msgid ""
"creating a ticket on the :github:`GitHub Issue Tracker <openresty/lua-nginx-"
"module/issues>`"
msgstr ""

#: ../../source/modules/lua.rst:384
msgid "or posting to the `OpenResty community <lua.community_>`_."
msgstr ""

#: ../../source/modules/lua.rst:389
msgid "Lua/LuaJIT bytecode support"
msgstr ""

#: ../../source/modules/lua.rst:390
msgid ""
"As from the ``v0.5.0rc32`` release, all ``*_by_lua_file`` configure "
"directives (such as `content_by_lua_file`_) support loading Lua 5.1 and "
"LuaJIT 2.0/2.1 raw bytecode files directly."
msgstr ""

#: ../../source/modules/lua.rst:392
msgid ""
"Please note that the bytecode format used by LuaJIT 2.0/2.1 is not "
"compatible with that used by the standard Lua 5.1 interpreter. So if using "
"LuaJIT 2.0/2.1 with ngx_lua, LuaJIT compatible bytecode files must be "
"generated as shown:"
msgstr ""

#: ../../source/modules/lua.rst:399
msgid ""
"The ``-bg`` option can be used to include debug information in the LuaJIT "
"bytecode file:"
msgstr ""

#: ../../source/modules/lua.rst:406
msgid ""
"Please refer to the official LuaJIT documentation on the ``-b`` option for "
"more details::"
msgstr ""

#: ../../source/modules/lua.rst:410
msgid ""
"Also, the bytecode files generated by LuaJIT 2.1 is *not* compatible with "
"LuaJIT 2.0, and vice versa. The support for LuaJIT 2.1 bytecode was first "
"added in ngx_lua v0.9.3."
msgstr ""

#: ../../source/modules/lua.rst:412
msgid ""
"Similarly, if using the standard Lua 5.1 interpreter with ngx_lua, Lua "
"compatible bytecode files must be generated using the ``luac`` commandline "
"utility as shown:"
msgstr ""

#: ../../source/modules/lua.rst:419
msgid ""
"Unlike as with LuaJIT, debug information is included in standard Lua 5.1 "
"bytecode files by default. This can be striped out by specifying the ``-s`` "
"option as shown:"
msgstr ""

#: ../../source/modules/lua.rst:426
msgid ""
"Attempts to load standard Lua 5.1 bytecode files into ngx_lua instances "
"linked to LuaJIT 2.0/2.1 or vice versa, will result in an error message, "
"such as that below, being logged into the Nginx ``error.log`` file:"
msgstr ""

#: ../../source/modules/lua.rst:435
msgid ""
"Loading bytecode files via the Lua primitives like ``require`` and "
"``dofile`` should always work as expected."
msgstr ""

#: ../../source/modules/lua.rst:440
msgid "System Environment Variable Support"
msgstr ""

#: ../../source/modules/lua.rst:441
msgid ""
"If you want to access the system environment variable, say, ``foo``, in Lua "
"via the standard Lua API `os.getenv "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.getenv>`_, then you should"
" also list this environment variable name in your ``nginx.conf`` file via "
"the `env directive <http://nginx.org/en/docs/ngx_core_module.html#env>`_. "
"For example:"
msgstr ""

#: ../../source/modules/lua.rst:450
msgid "HTTP 1.0 support"
msgstr ""

#: ../../source/modules/lua.rst:451
msgid ""
"The HTTP 1.0 protocol does not support chunked output and requires an "
"explicit ``Content-Length`` header when the response body is not empty in "
"order to support the HTTP 1.0 keep-alive. So when a HTTP 1.0 request is made"
" and the `lua_http10_buffering`_ directive is turned ``on``, ngx_lua will "
"buffer the output of `ngx.say`_ and `ngx.print`_ calls and also postpone "
"sending response headers until all the response body output is received. At "
"that time ngx_lua can calculate the total length of the body and construct a"
" proper ``Content-Length`` header to return to the HTTP 1.0 client. If the "
"``Content-Length`` response header is set in the running Lua code, however, "
"this buffering will be disabled even if the `lua_http10_buffering`_ "
"directive is turned ``on``."
msgstr ""

#: ../../source/modules/lua.rst:453
msgid ""
"For large streaming output responses, it is important to disable the "
"`lua_http10_buffering`_ directive to minimise memory usage."
msgstr ""

#: ../../source/modules/lua.rst:455
msgid ""
"Note that common HTTP benchmark tools such as ``ab`` and ``http_load`` issue"
" HTTP 1.0 requests by default."
msgstr ""

#: ../../source/modules/lua.rst:457
msgid "To force ``curl`` to send HTTP 1.0 requests, use the ``-0`` option."
msgstr ""

#: ../../source/modules/lua.rst:462
msgid "Statically Linking Pure Lua Modules"
msgstr ""

#: ../../source/modules/lua.rst:463
msgid ""
"When LuaJIT 2.x is used, it is possible to statically link the bytecode of "
"pure Lua modules into the Nginx executable."
msgstr ""

#: ../../source/modules/lua.rst:465
msgid ""
"Basically you use the ``luajit`` executable to compile ``.lua`` Lua module "
"files to ``.o`` object files containing the exported bytecode data, and then"
" link the ``.o`` files directly in your Nginx build."
msgstr ""

#: ../../source/modules/lua.rst:467
msgid ""
"Below is a trivial example to demonstrate this. Consider that we have the "
"following ``.lua`` file named ``foo.lua``:"
msgstr ""

#: ../../source/modules/lua.rst:483
msgid "And then we compile this ``.lua`` file to ``foo.o`` file:"
msgstr ""

#: ../../source/modules/lua.rst:490
msgid ""
"What matters here is the name of the ``.lua`` file, which determines how you"
" use this module later on the Lua land. The file name ``foo.o`` does not "
"matter at all except the ``.o`` file extension (which tells ``luajit`` what "
"output format is used). If you want to strip the Lua debug information from "
"the resulting bytecode, you can just specify the ``-b`` option above instead"
" of ``-bg``."
msgstr ""

#: ../../source/modules/lua.rst:492
msgid ""
"Then when building Nginx or OpenResty, pass the ``--with-ld-opt=\"foo.o\"`` "
"option to the ``./configure`` script:"
msgstr ""

#: ../../source/modules/lua.rst:499
msgid "Finally, you can just do the following in any Lua code run by ngx_lua:"
msgstr ""

#: ../../source/modules/lua.rst:507
msgid ""
"And this piece of code no longer depends on the external ``foo.lua`` file "
"any more because it has already been compiled into the ``nginx`` executable."
msgstr ""

#: ../../source/modules/lua.rst:509
msgid ""
"If you want to use dot in the Lua module name when calling ``require``, as "
"in"
msgstr ""

#: ../../source/modules/lua.rst:516
msgid ""
"then you need to rename the ``foo.lua`` file to ``resty_foo.lua`` before "
"compiling it down to a ``.o`` file with the ``luajit`` command-line utility."
msgstr ""

#: ../../source/modules/lua.rst:518
msgid ""
"It is important to use exactly the same version of LuaJIT when compiling "
"``.lua`` files to ``.o`` files as building nginx + ngx_lua. This is because "
"the LuaJIT bytecode format may be incompatible between different LuaJIT "
"versions. When the bytecode format is incompatible, you will see a Lua "
"runtime error saying that the Lua module is not found."
msgstr ""

#: ../../source/modules/lua.rst:520
msgid ""
"When you have multiple ``.lua`` files to compile and link, then just specify"
" their ``.o`` files at the same time in the value of the ``--with-ld-opt`` "
"option. For instance,"
msgstr ""

#: ../../source/modules/lua.rst:527
msgid ""
"If you have just too many ``.o`` files, then it might not be feasible to "
"name them all in a single command. In this case, you can build a static "
"library (or archive) for your ``.o`` files, as in"
msgstr ""

#: ../../source/modules/lua.rst:534
msgid ""
"then you can link the ``myluafiles`` archive as a whole to your nginx "
"executable:"
msgstr ""

#: ../../source/modules/lua.rst:542
msgid ""
"where ``/path/to/lib`` is the path of the directory containing the "
"``libmyluafiles.a`` file. It should be noted that the linker option "
"``--whole-archive`` is required here because otherwise our archive will be "
"skipped because no symbols in our archive are mentioned in the main parts of"
" the nginx executable."
msgstr ""

#: ../../source/modules/lua.rst:547
msgid "Data Sharing within an Nginx Worker"
msgstr ""

#: ../../source/modules/lua.rst:548
msgid ""
"To globally share data among all the requests handled by the same nginx "
"worker process, encapsulate the shared data into a Lua module, use the Lua "
"``require`` builtin to import the module, and then manipulate the shared "
"data in Lua. This works because required Lua modules are loaded only once "
"and all coroutines will share the same copy of the module (both its code and"
" data). Note however that Lua global variables (note, not module-level "
"variables) WILL NOT persist between requests because of the one-coroutine-"
"per-request isolation design."
msgstr ""

#: ../../source/modules/lua.rst:550
msgid "Here is a complete small example:"
msgstr ""

#: ../../source/modules/lua.rst:570
msgid "and then accessing it from ``nginx.conf``:"
msgstr ""

#: ../../source/modules/lua.rst:582
msgid ""
"The ``mydata`` module in this example will only be loaded and run on the "
"first request to the location ``/lua``, and all subsequent requests to the "
"same nginx worker process will use the reloaded instance of the module as "
"well as the same copy of the data in it, until a ``HUP`` signal is sent to "
"the Nginx master process to force a reload. This data sharing technique is "
"essential for high performance Lua applications based on this module."
msgstr ""

#: ../../source/modules/lua.rst:584
msgid ""
"that this data sharing is on a *per-worker* basis and not on a *per-server* "
"basis. That is, when there are multiple nginx worker processes under an "
"Nginx master, data sharing cannot cross the process boundary between these "
"workers."
msgstr ""

#: ../../source/modules/lua.rst:586
msgid ""
"It is usually recommended to share read-only data this way. You can also "
"share changeable data among all the concurrent requests of each nginx worker"
" process as long as there is *no* nonblocking I/O operations (including "
"`ngx.sleep`_) in the middle of your calculations. As long as you do not give"
" the control back to the nginx event loop and ngx_lua's light thread "
"scheduler (even implicitly), there can never be any race conditions in "
"between. For this reason, always be very careful when you want to share "
"changeable data on the worker level. Buggy optimizations can easily lead to "
"hard-to-debug race conditions under load."
msgstr ""

#: ../../source/modules/lua.rst:588
msgid ""
"If server-wide data sharing is required, then use one or more of the "
"following approaches:"
msgstr ""

#: ../../source/modules/lua.rst:590
msgid "Use the `ngx.shared.DICT`_ API provided by this module."
msgstr ""

#: ../../source/modules/lua.rst:591
msgid ""
"Use only a single nginx worker and a single server (this is however not "
"recommended when there is a multi core CPU or multiple CPUs in a single "
"machine)."
msgstr ""

#: ../../source/modules/lua.rst:592
msgid ""
"Use data storage mechanisms such as ``memcached``, ``redis``, ``MySQL`` or "
"``PostgreSQL``. `The ngx_openresty bundle <http://openresty.org>`_ "
"associated with this module comes with a set of companion Nginx modules and "
"Lua libraries that provide interfaces with these data storage mechanisms."
msgstr ""

#: ../../source/modules/lua.rst:597
msgid "Known Issues"
msgstr ""

#: ../../source/modules/lua.rst:600
msgid "TCP socket connect operation issues"
msgstr ""

#: ../../source/modules/lua.rst:601
msgid ""
"The `tcpsock:connect`_ method may indicate ``success`` despite connection "
"failures such as with ``Connection Refused`` errors."
msgstr ""

#: ../../source/modules/lua.rst:603
msgid ""
"However, later attempts to manipulate the cosocket object will fail and "
"return the actual error status message generated by the failed connect "
"operation."
msgstr ""

#: ../../source/modules/lua.rst:605
msgid ""
"This issue is due to limitations in the Nginx event model and only appears "
"to affect Mac OS X."
msgstr ""

#: ../../source/modules/lua.rst:609
msgid "Lua Coroutine Yielding/Resuming"
msgstr ""

#: ../../source/modules/lua.rst:610
msgid ""
"Because Lua's ``dofile`` and ``require`` builtins are currently implemented "
"as C functions in both Lua 5.1 and LuaJIT 2.0/2.1, if the Lua file being "
"loaded by ``dofile`` or ``require`` invokes `ngx.location.capture`_, "
"`ngx.exec`_, `ngx.exit`_, or other API functions requiring yielding in the "
"*top-level* scope of the Lua file, then the Lua error \"attempt to yield "
"across C-call boundary\" will be raised. To avoid this, put these calls "
"requiring yielding into your own Lua functions in the Lua file instead of "
"the top-level scope of the file."
msgstr ""

#: ../../source/modules/lua.rst:612
msgid ""
"As the standard Lua 5.1 interpreter's VM is not fully resumable, the methods"
" `ngx.location.capture`_, `ngx.location.capture_multi`_, `ngx.redirect`_, "
"`ngx.exec`_, and `ngx.exit`_ cannot be used within the context of a Lua "
"`pcall() <http://www.lua.org/manual/5.1/manual.html#pdf-pcall>`_ or "
"`xpcall() <http://www.lua.org/manual/5.1/manual.html#pdf-xpcall>`_ or even "
"the first line of the ``for ... in ...`` statement when the standard Lua 5.1"
" interpreter is used and the ``attempt to yield across metamethod/C-call "
"boundary`` error will be produced. Please use LuaJIT 2.x, which supports a "
"fully resumable VM, to avoid this."
msgstr ""

#: ../../source/modules/lua.rst:616
msgid "Lua Variable Scope"
msgstr ""

#: ../../source/modules/lua.rst:617
msgid ""
"Care must be taken when importing modules and this form should be used:"
msgstr ""

#: ../../source/modules/lua.rst:624
msgid "instead of the old deprecated form:"
msgstr ""

#: ../../source/modules/lua.rst:631
msgid ""
"Here is the reason: by design, the global environment has exactly the same "
"lifetime as the Nginx request handler associated with it. Each request "
"handler has its own set of Lua global variables and that is the idea of "
"request isolation. The Lua module is actually loaded by the first Nginx "
"request handler and is cached by the ``require()`` built-in in the "
"``package.loaded`` table for later reference, and the ``module()`` builtin "
"used by some Lua modules has the side effect of setting a global variable to"
" the loaded module table. But this global variable will be cleared at the "
"end of the request handler,  and every subsequent request handler all has "
"its own (clean) global environment. So one will get Lua exception for "
"accessing the ``nil`` value."
msgstr ""

#: ../../source/modules/lua.rst:633
msgid ""
"Generally, use of Lua global variables is a really really bad idea in the "
"context of ngx_lua because"
msgstr ""

#: ../../source/modules/lua.rst:635
msgid ""
"misuse of Lua globals has very bad side effects for concurrent requests when"
" these variables are actually supposed to be local only,"
msgstr ""

#: ../../source/modules/lua.rst:636
msgid ""
"Lua global variables require Lua table look-up in the global environment "
"(which is just a Lua table), which is kinda expensive, and"
msgstr ""

#: ../../source/modules/lua.rst:637
msgid ""
"some Lua global variable references are just typos, which are hard to debug."
msgstr ""

#: ../../source/modules/lua.rst:639
msgid ""
"It's *highly* recommended to always declare them via \"local\" in the scope "
"that is reasonable."
msgstr ""

#: ../../source/modules/lua.rst:641
msgid ""
"To find out all the uses of Lua global variables in your Lua code, you can "
"run the :github:`lua-releng tool <openresty/nginx-devel-utils/blob/master"
"/lua-releng>` across all your .lua source files:"
msgstr ""

#: ../../source/modules/lua.rst:651
msgid ""
"The output says that the line 1489 of file ``lib/foo/bar.lua`` writes to a "
"global variable named ``contains``, the line 1506 reads from the global "
"variable ``setvar``, and line 1545 reads the global ``varexpand``."
msgstr ""

#: ../../source/modules/lua.rst:653
msgid ""
"This tool will guarantee that local variables in the Lua module functions "
"are all declared with the ``local`` keyword, otherwise a runtime exception "
"will be thrown. It prevents undesirable race conditions while accessing such"
" variables."
msgstr ""

#: ../../source/modules/lua.rst:655
msgid ""
"See `Data Sharing within an Nginx Worker`_ for the reasons behind this."
msgstr ""

#: ../../source/modules/lua.rst:659
msgid "Locations Configured by Subrequest Directives of Other Modules"
msgstr ""

#: ../../source/modules/lua.rst:660
msgid ""
"The `ngx.location.capture`_ and `ngx.location.capture_multi`_ directives "
"cannot capture locations that include the `add_before_body "
"<|HttpAdditionModule|#add_before_body>`_, `add_after_body "
"<|HttpAdditionModule|#add_after_body>`_, `auth_request "
"<http://nginx.org/en/docs/http/ngx_http_auth_request_module.html#auth_request>`_,"
" `echo_location <|HttpEchoModule|#echo_location>`_, `echo_location_async "
"<|HttpEchoModule|#echo_location_async>`_, `echo_subrequest "
"<|HttpEchoModule|#echo_subrequest>`_, or `echo_subrequest_async "
"<|HttpEchoModule|#echo_subrequest_async>`_ directives."
msgstr ""

#: ../../source/modules/lua.rst:682
msgid "will not work as expected."
msgstr ""

#: ../../source/modules/lua.rst:686
msgid "Cosockets Not Available Everywhere"
msgstr ""

#: ../../source/modules/lua.rst:687
msgid ""
"Due the internal limitations in the nginx core, the cosocket API are "
"disabled in the following contexts: `set_by_lua`_, `log_by_lua`_, "
"`header_filter_by_lua`_, and `body_filter_by_lua`_."
msgstr ""

#: ../../source/modules/lua.rst:689
msgid ""
"The cosockets are currently also disabled in the `init_by_lua`_ and "
"`init_worker_by_lua`_ directive contexts but we may add support for these "
"contexts in the future because there is no limitation in the nginx core (or "
"the limitation might be worked around)."
msgstr ""

#: ../../source/modules/lua.rst:691
msgid ""
"There exists a work-around, however, when the original context does *not* "
"need to wait for the cosocket results. That is, creating a 0-delay timer via"
" the `ngx.timer.at`_ API and do the cosocket results in the timer handler, "
"which runs asynchronously as to the original context creating the timer."
msgstr ""

#: ../../source/modules/lua.rst:695
msgid "Special Escaping Sequences"
msgstr ""

#: ../../source/modules/lua.rst:696
msgid ""
"PCRE sequences such as ``\\d``, ``\\s``, or ``\\w``, require special "
"attention because in string literals, the backslash character, ``\\``, is "
"stripped out by both the Lua language parser and by the Nginx config file "
"parser before processing. So the following snippet will not work as "
"expected:"
msgstr ""

#: ../../source/modules/lua.rst:710
msgid "To avoid this, *double* escape the backslash:"
msgstr ""

#: ../../source/modules/lua.rst:725
msgid ""
"Here, ``\\\\\\\\d+`` is stripped down to ``\\\\d+`` by the Nginx config file"
" parser and this is further stripped down to ``\\d+`` by the Lua language "
"parser before running."
msgstr ""

#: ../../source/modules/lua.rst:727
msgid ""
"Alternatively, the regex pattern can be presented as a long-bracketed Lua "
"string literal by encasing it in \"long brackets\", ``&#91;[...]]``, in "
"which case backslashes have to only be escaped once for the Nginx config "
"file parser."
msgstr ""

#: ../../source/modules/lua.rst:742
msgid ""
"Here, ``&#91;[\\\\d+]]`` is stripped down to ``&#91;[\\d+]]`` by the Nginx "
"config file parser and this is processed correctly."
msgstr ""

#: ../../source/modules/lua.rst:745
msgid ""
"Note that a longer from of the long bracket, ``[=[...]=]``, may be required "
"if the regex pattern contains ``&#91;...]`` sequences."
msgstr ""

#: ../../source/modules/lua.rst:745
msgid "The ``[=[...]=]`` form may be used as the default form if desired."
msgstr ""

#: ../../source/modules/lua.rst:760
msgid ""
"An alternative approach to escaping PCRE sequences is to ensure that Lua "
"code is placed in external script files and executed using the various "
"``*_by_lua_file`` directives."
msgstr ""

#: ../../source/modules/lua.rst:762
msgid ""
"With this approach, the backslashes are only stripped by the Lua language "
"parser and therefore only need to be escaped once each."
msgstr ""

#: ../../source/modules/lua.rst:773
msgid ""
"Within external script files, PCRE sequences presented as long-bracketed Lua"
" string literals do not require modification."
msgstr ""

#: ../../source/modules/lua.rst:785
msgid "Mixing with SSI Not Supported"
msgstr ""

#: ../../source/modules/lua.rst:786
msgid ""
"Mixing SSI with ngx_lua in the same Nginx request is not supported at all. "
"Just use ngx_lua exclusively. Everything you can do with SSI can be done "
"atop ngx_lua anyway and it can be more efficient when using ngx_lua."
msgstr ""

#: ../../source/modules/lua.rst:790
msgid "SPDY Mode Not Fully Supported"
msgstr ""

#: ../../source/modules/lua.rst:791
msgid ""
"Certain Lua APIs provided by ngx_lua do not work in Nginx's SPDY mode yet: "
"`ngx.location.capture`_, `ngx.location.capture_multi`_, and "
"`ngx.req.socket`_."
msgstr ""

#: ../../source/modules/lua.rst:796
msgid "Missing data on short circuited requests"
msgstr ""

#: ../../source/modules/lua.rst:797
msgid "Nginx may terminate a request early with (at least):"
msgstr ""

#: ../../source/modules/lua.rst:799
msgid "400 (Bad Request)"
msgstr ""

#: ../../source/modules/lua.rst:800
msgid "405 (Not Allowed)"
msgstr ""

#: ../../source/modules/lua.rst:801
msgid "408 (Request Timeout)"
msgstr ""

#: ../../source/modules/lua.rst:802
msgid "414 (Request URI Too Large)"
msgstr ""

#: ../../source/modules/lua.rst:803
msgid "494 (Request Headers Too Large)"
msgstr ""

#: ../../source/modules/lua.rst:804
msgid "499 (Client Closed Request)"
msgstr ""

#: ../../source/modules/lua.rst:805
msgid "500 (Internal Server Error)"
msgstr ""

#: ../../source/modules/lua.rst:806
msgid "501 (Not Implemented)"
msgstr ""

#: ../../source/modules/lua.rst:808
msgid ""
"This means that phases that normally run are skipped, such as the rewrite or"
" access phase. This also means that later phases that are run regardless, "
"e.g. `log_by_lua`_, will not have access to information that is normally set"
" in those phases."
msgstr ""

#: ../../source/modules/lua.rst:813
msgid "TODO"
msgstr ""

#: ../../source/modules/lua.rst:814
msgid ""
"add ``*_by_lua_block`` directives for existing ``*_by_lua`` directives so "
"that we put literal Lua code directly in curly braces instead of an nginx "
"literal string. For example,"
msgstr ""

#: ../../source/modules/lua.rst:822 ../../source/modules/lua.rst:3697
msgid "which is equivalent to"
msgstr ""

#: ../../source/modules/lua.rst:830
msgid "but the former is much cleaner and nicer."
msgstr ""

#: ../../source/modules/lua.rst:831
msgid "cosocket: implement LuaSocket's unconnected UDP API."
msgstr ""

#: ../../source/modules/lua.rst:832
msgid ""
"add support for implementing general TCP servers instead of HTTP servers in "
"Lua. For example,"
msgstr ""

#: ../../source/modules/lua.rst:846
msgid ""
"add support for implementing general UDP servers instead of HTTP servers in "
"Lua. For example,"
msgstr ""

#: ../../source/modules/lua.rst:859
msgid ""
"ssl: implement directives ``ssl_certificate_by_lua`` and "
"``ssl_certificate_by_lua_file`` to allow using Lua to dynamically serve SSL "
"certificates and keys for downstream SSL handshake. (already done in "
"CloudFlare's private branch and powering CloudFlare's SSL gateway of its "
"global network. expected to be opensourced in March 2015.)"
msgstr ""

#: ../../source/modules/lua.rst:860
msgid ""
"shm: implement a \"shared queue API\" to complement the existing `shared "
"dict <ngx.shared.DICT_>`__ API."
msgstr ""

#: ../../source/modules/lua.rst:861
msgid "cosocket: add support in the context of `init_by_lua`_."
msgstr ""

#: ../../source/modules/lua.rst:862
msgid "cosocket: implement the ``bind()`` method for stream-typed cosockets."
msgstr ""

#: ../../source/modules/lua.rst:863
msgid ""
"cosocket: pool-based backend concurrency level control: implement automatic "
"``connect`` queueing when the backend concurrency exceeds its connection "
"pool limit."
msgstr ""

#: ../../source/modules/lua.rst:864
msgid ""
"cosocket: review and merge aviramc's :github:`patch <openresty/lua-nginx-"
"module/pull/290>` for adding the ``bsdrecv`` method."
msgstr ""

#: ../../source/modules/lua.rst:865
msgid ""
"add new API function ``ngx.resp.add_header`` to emulate the standard "
"``add_header`` config directive."
msgstr ""

#: ../../source/modules/lua.rst:866
msgid ""
"`ngx.re <ngx.re.match_>`_ API: use ``false`` instead of ``nil`` in the "
"resulting match table to indicate non-existent submatch captures, such that "
"we can avoid \"holes\" in the array table."
msgstr ""

#: ../../source/modules/lua.rst:867
msgid "review and apply Jader H. Silva's patch for ``ngx.re.split()``."
msgstr ""

#: ../../source/modules/lua.rst:868
msgid ""
"review and apply vadim-pavlov's patch for `ngx.location.capture`_'s "
"``extra_headers`` option"
msgstr ""

#: ../../source/modules/lua.rst:869
msgid ""
"use ``ngx_hash_t`` to optimize the built-in header look-up process for "
"`ngx.req.set_header`_, `ngx.header.HEADER`_, and etc."
msgstr ""

#: ../../source/modules/lua.rst:870
msgid ""
"add configure options for different strategies of handling the cosocket "
"connection exceeding in the pools."
msgstr ""

#: ../../source/modules/lua.rst:871
msgid "add directives to run Lua codes when nginx stops."
msgstr ""

#: ../../source/modules/lua.rst:872
msgid ""
"add ``ignore_resp_headers``, ``ignore_resp_body``, and ``ignore_resp`` "
"options to `ngx.location.capture`_ and `ngx.location.capture_multi`_ "
"methods, to allowmicro performance tuning on the user side."
msgstr ""

#: ../../source/modules/lua.rst:873
msgid ""
"add automatic Lua code time slicing support by yielding and resuming the Lua"
" VM actively via Lua's debug hooks."
msgstr ""

#: ../../source/modules/lua.rst:874
msgid ""
"add ``stat`` mode similar to `mod_lua "
"<https://httpd.apache.org/docs/trunk/mod/mod_lua.html>`_."
msgstr ""

#: ../../source/modules/lua.rst:879
msgid "Changes"
msgstr ""

#: ../../source/modules/lua.rst:880
msgid ""
"The changes of every release of this module can be obtained from the "
"ngx_openresty bundle's change logs:"
msgstr ""

#: ../../source/modules/lua.rst:882
msgid "http://openresty.org/#Changes"
msgstr ""

#: ../../source/modules/lua.rst:887
msgid "Test Suite"
msgstr ""

#: ../../source/modules/lua.rst:888
msgid "The following dependencies are required to run the test suite:"
msgstr ""

#: ../../source/modules/lua.rst:890
msgid "Nginx version >= 1.4.2"
msgstr ""

#: ../../source/modules/lua.rst:891
msgid "Perl modules: - Test::Nginx: https://github.com/openresty/test-nginx"
msgstr ""

#: ../../source/modules/lua.rst:893
msgid ""
"Nginx modules: - :github:`ngx_devel_kit <simpl/ngx_devel_kit>` - "
":github:`ngx_set_misc <openresty/set-misc-nginx-module>` - `ngx_auth_request"
" <http://mdounin.ru/files/ngx_http_auth_request_module-0.2.tar.gz>` (this is"
" not needed if you're using Nginx 1.5.4+). - :github:`ngx_echo <openresty"
"/echo-nginx-module>` - :github:`ngx_memc <openresty/memc-nginx-module>` - "
":github:`ngx_srcache <openresty/srcache-nginx-module>` - ngx_lua (i.e., this"
" module) - :github:`ngx_lua_upstream <openresty/lua-upstream-nginx-module>` "
"- :github:`ngx_headers_more <openresty/headers-more-nginx-module>` - "
":github:`ngx_drizzle <openresty/drizzle-nginx-module>` - "
":github:`ngx_rds_json <openresty/rds-json-nginx-module>` - "
":github:`ngx_coolkit <FRiCKLE/ngx_coolkit>` - :github:`ngx_redis2 "
"<openresty/redis2-nginx-module>`"
msgstr ""

#: ../../source/modules/lua.rst:908
msgid ""
"The order in which these modules are added during configuration is important"
" because the position of any filter module in the filtering chain determines"
" the final output, for example. The correct adding order is shown above."
msgstr ""

#: ../../source/modules/lua.rst:910
msgid ""
"3rd-party Lua libraries: - `lua-cjson <http://www.kyne.com.au/~mark/software"
"/lua-cjson.php>`__"
msgstr ""

#: ../../source/modules/lua.rst:912
msgid ""
"Applications: - mysql: create database 'ngx_test', grant all privileges to "
"user 'ngx_test', password is 'ngx_test' - memcached: listening on the "
"default port, 11211. - redis: listening on the default port, 6379."
msgstr ""

#: ../../source/modules/lua.rst:917
msgid ""
"the :github:`developer build script <openresty/lua-nginx-"
"module/blob/master/util/build2.sh>` for more details on setting up the "
"testing environment."
msgstr ""

#: ../../source/modules/lua.rst:919
msgid "To run the whole test suite in the default testing mode:"
msgstr ""

#: ../../source/modules/lua.rst:928
msgid "To run specific test files:"
msgstr ""

#: ../../source/modules/lua.rst:937
msgid ""
"To run a specific test block in a particular test file, add the line ``--- "
"ONLY`` to the test block you want to run, and then use the `prove` utilityto"
" run that ``.t`` file."
msgstr ""

#: ../../source/modules/lua.rst:939
msgid ""
"There are also various testing modes based on mockeagain, valgrind, and etc."
" Refer to the `Test::Nginx documentation "
"<http://search.cpan.org/perldoc?Test::Nginx>`_ for more details for various "
"advanced testing modes. See also the test reports for the Nginx test cluster"
" running on Amazon EC2: http://qa.openresty.org."
msgstr ""

#: ../../source/modules/lua.rst:944
msgid "Copyright and License"
msgstr ""

#: ../../source/modules/lua.rst:946
msgid "This module is licensed under the BSD license."
msgstr ""

#: ../../source/modules/lua.rst:948
msgid ""
"Copyright (C) 2009-2015, by Xiaozhe Wang (chaoslawful) "
"<chaoslawful@gmail.com>."
msgstr ""

#: ../../source/modules/lua.rst:950
msgid ""
"Copyright (C) 2009-2015, by Yichun \"agentzh\" Zhang (章亦春) "
"<agentzh@gmail.com>, CloudFlare Inc."
msgstr ""

#: ../../source/modules/lua.rst:952
msgid "All rights reserved."
msgstr ""

#: ../../source/modules/lua.rst:954
msgid ""
"Redistribution and use in source and binary forms, with or without "
"modification, are permitted provided that the following conditions are met:"
msgstr ""

#: ../../source/modules/lua.rst:956
msgid ""
"Redistributions of source code must retain the above copyright notice, this "
"list of conditions and the following disclaimer."
msgstr ""

#: ../../source/modules/lua.rst:957
msgid ""
"Redistributions in binary form must reproduce the above copyright notice, "
"this list of conditions and the following disclaimer in the documentation "
"and/or other materials provided with the distribution."
msgstr ""

#: ../../source/modules/lua.rst:959
msgid ""
"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS "
"IS\" AND  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, "
"THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR "
"PURPOSE ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR "
"CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, "
"EXEMPLARY, OR CONSEQUENTIAL DAMAGES  (INCLUDING, BUT NOT LIMITED TO, "
"PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE, DATA, OR PROFITS;"
" OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON  ANY THEORY OF LIABILITY, "
"WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR "
"OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF "
"ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
msgstr ""

#: ../../source/modules/lua.rst:963
msgid ""
":github:`lua-resty-memcached <openresty/lua-resty-memcached>` library based "
"on ngx_lua cosocket."
msgstr ""

#: ../../source/modules/lua.rst:964
msgid ""
":github:`lua-resty-redis <openresty/lua-resty-redis>` library based on "
"ngx_lua cosocket."
msgstr ""

#: ../../source/modules/lua.rst:965
msgid ""
":github:`lua-resty-mysql <openresty/lua-resty-mysql>` library based on "
"ngx_lua cosocket."
msgstr ""

#: ../../source/modules/lua.rst:966
msgid ""
":github:`lua-resty-upload <openresty/lua-resty-upload>` library based on "
"ngx_lua cosocket."
msgstr ""

#: ../../source/modules/lua.rst:967
msgid ""
":github:`lua-resty-dns <openresty/lua-resty-dns>` library based on ngx_lua "
"cosocket."
msgstr ""

#: ../../source/modules/lua.rst:968
msgid ""
":github:`lua-resty-websocket <openresty/lua-resty-websocket>` library for "
"both WebSocket server and client, based on ngx_lua cosocket."
msgstr ""

#: ../../source/modules/lua.rst:969
msgid ""
":github:`lua-resty-string <openresty/lua-resty-string>` library based on "
"`LuaJIT FFI <http://luajit.org/ext_ffi.html>`_."
msgstr ""

#: ../../source/modules/lua.rst:970
msgid ""
":github:`lua-resty-lock <openresty/lua-resty-lock>` library for a "
"nonblocking simple lock API."
msgstr ""

#: ../../source/modules/lua.rst:971
msgid ""
":github:`lua-resty-cookie <cloudflare/lua-resty-cookie>` library for HTTP "
"cookie manipulation."
msgstr ""

#: ../../source/modules/lua.rst:972
msgid ""
"`Routing requests to different MySQL queries based on URI arguments "
"<http://openresty.org/#RoutingMySQLQueriesBasedOnURIArgs>`_"
msgstr ""

#: ../../source/modules/lua.rst:973
msgid ""
"`Dynamic Routing Based on Redis and Lua "
"<http://openresty.org/#DynamicRoutingBasedOnRedis>`_"
msgstr ""

#: ../../source/modules/lua.rst:974
msgid "`Using LuaRocks with ngx_lua <http://openresty.org/#UsingLuaRocks>`_"
msgstr ""

#: ../../source/modules/lua.rst:975
msgid ""
":github:`Introduction to ngx_lua <openresty/lua-nginx-"
"module/wiki/Introduction>`"
msgstr ""

#: ../../source/modules/lua.rst:976
msgid ":github:`ngx_devel_kit <simpl/ngx_devel_kit>`"
msgstr ""

#: ../../source/modules/lua.rst:977
msgid ":doc:`echo`"
msgstr ""

#: ../../source/modules/lua.rst:978
msgid ":doc:`drizzle`"
msgstr ""

#: ../../source/modules/lua.rst:979
msgid ":github:`postgres-nginx-module <FRiCKLE/ngx_postgres>`"
msgstr ""

#: ../../source/modules/lua.rst:980
msgid ":doc:`memc`"
msgstr ""

#: ../../source/modules/lua.rst:981
msgid "`The ngx_openresty bundle <http://openresty.org>`_"
msgstr ""

#: ../../source/modules/lua.rst:982
msgid ":github:`Nginx Systemtap Toolkit <openresty/nginx-systemtap-toolkit>`"
msgstr ""

#: ../../source/modules/lua.rst:985
msgid "Directives"
msgstr ""

#: ../../source/modules/lua.rst:991
msgid "lua_use_default_type"
msgstr ""

#: ../../source/modules/lua.rst:992
msgid "*lua_use_default_type on | off*"
msgstr ""

#: ../../source/modules/lua.rst:993
msgid "*lua_use_default_type on*"
msgstr ""

#: ../../source/modules/lua.rst:994 ../../source/modules/lua.rst:1007
#: ../../source/modules/lua.rst:1329 ../../source/modules/lua.rst:1452
#: ../../source/modules/lua.rst:1471 ../../source/modules/lua.rst:1541
#: ../../source/modules/lua.rst:1560 ../../source/modules/lua.rst:1588
#: ../../source/modules/lua.rst:1601 ../../source/modules/lua.rst:1688
#: ../../source/modules/lua.rst:1701 ../../source/modules/lua.rst:1762
#: ../../source/modules/lua.rst:1776
msgid "*http, server, location, location if*"
msgstr ""

#: ../../source/modules/lua.rst:996
msgid ""
"Specifies whether to use the MIME type specified by the `default_type "
"<http://nginx.org/en/docs/http/ngx_http_core_module.html#default_type>`_ "
"directive for the default value of the ``Content-Type`` response header. If "
"you do not want a default ``Content-Type`` response header for your Lua "
"request handlers, then turn this directive off."
msgstr ""

#: ../../source/modules/lua.rst:998
msgid "This directive is turned on by default."
msgstr ""

#: ../../source/modules/lua.rst:1000
msgid "This directive was first introduced in the ``v0.9.1`` release."
msgstr ""

#: ../../source/modules/lua.rst:1004
msgid "lua_code_cache"
msgstr ""

#: ../../source/modules/lua.rst:1005
msgid "*lua_code_cache on | off*"
msgstr ""

#: ../../source/modules/lua.rst:1006
msgid "*lua_code_cache on*"
msgstr ""

#: ../../source/modules/lua.rst:1009
msgid ""
"Enables or disables the Lua code cache for Lua code in ``*_by_lua_file`` "
"directives (like `set_by_lua_file`_ and `content_by_lua_file`_) and Lua "
"modules."
msgstr ""

#: ../../source/modules/lua.rst:1011
msgid ""
"When turning off, every request served by ngx_lua will run in a separate Lua"
" VM instance, starting from the ``0.9.3`` release. So the Lua files "
"referenced in `set_by_lua_file`_, `content_by_lua_file`_, "
"`access_by_lua_file`_, and etc will not be cached and all Lua modules used "
"will be loaded from scratch. With this inplace, developers can adopt an "
"edit-and-refresh approach."
msgstr ""

#: ../../source/modules/lua.rst:1013
msgid ""
"Please note however, that Lua code written inlined within nginx.conf such as"
" those specified by `set_by_lua`_, `content_by_lua`_, `access_by_lua`_, and "
"`rewrite_by_lua`_ will not be updated when you edit the inlined Lua code in "
"your``nginx.conf`` file because only the Nginx config file parser can "
"correctly parse the ``nginx.conf`` file and the only way is to reload the "
"config file by sending a ``HUP`` signal or just to restart Nginx."
msgstr ""

#: ../../source/modules/lua.rst:1015
msgid ""
"Even when the code cache is enabled, Lua files which are loaded by "
"``dofile`` or ``loadfile`` in ``*_by_lua_file`` cannot be cached (unless you"
" cache the results yourself). Usually you can either use the `init_by_lua`_ "
"or `init_by_lua_file`_ directives to load all such files or just make these "
"Lua files true Lua modules and load them via ``require``."
msgstr ""

#: ../../source/modules/lua.rst:1017
msgid ""
"The ngx_lua module does not support the ``stat`` mode available with the "
"Apache ``mod_lua`` module (yet)."
msgstr ""

#: ../../source/modules/lua.rst:1019
msgid ""
"Disabling the Lua code cache is strongly discouraged for production use and "
"should only be used during development as it has a significant negative "
"impact on overall performance. For example, the performance a \"hello "
"world\" Lua example can drop by an order of magnitude after disabling the "
"Lua code cache."
msgstr ""

#: ../../source/modules/lua.rst:1023
msgid "lua_regex_cache_max_entries"
msgstr ""

#: ../../source/modules/lua.rst:1024
msgid "*lua_regex_cache_max_entries <num>*"
msgstr ""

#: ../../source/modules/lua.rst:1025
msgid "*lua_regex_cache_max_entries 1024*"
msgstr ""

#: ../../source/modules/lua.rst:1026 ../../source/modules/lua.rst:1046
#: ../../source/modules/lua.rst:1061 ../../source/modules/lua.rst:1072
#: ../../source/modules/lua.rst:1082 ../../source/modules/lua.rst:1149
#: ../../source/modules/lua.rst:1162 ../../source/modules/lua.rst:1203
#: ../../source/modules/lua.rst:1794 ../../source/modules/lua.rst:2003
#: ../../source/modules/lua.rst:2056 ../../source/modules/lua.rst:2071
msgid "*http*"
msgstr ""

#: ../../source/modules/lua.rst:1028
msgid ""
"Specifies the maximum number of entries allowed in the worker process level "
"compiled regex cache."
msgstr ""

#: ../../source/modules/lua.rst:1030
msgid ""
"The regular expressions used in `ngx.re.match`_, `ngx.re.gmatch`_, "
"`ngx.re.sub`_, and `ngx.re.gsub`_ will be cached within this cache if the "
"regex option ``o`` (i.e., compile-once flag) is specified."
msgstr ""

#: ../../source/modules/lua.rst:1032
msgid ""
"The default number of entries allowed is 1024 and when this limit is "
"reached, new regular expressions will not be cached (as if the ``o`` option "
"was not specified) and there will be one, and only one, warning in the "
"``error.log`` file:"
msgstr ""

#: ../../source/modules/lua.rst:1039
msgid ""
"Do not activate the ``o`` option for regular expressions (and/or ``replace``"
" string arguments for `ngx.re.sub`_ and `ngx.re.gsub`_) that are generated "
"*on the fly* and give rise to infinite variations to avoid hitting the "
"specified limit."
msgstr ""

#: ../../source/modules/lua.rst:1043
msgid "lua_regex_match_limit"
msgstr ""

#: ../../source/modules/lua.rst:1044
msgid "*lua_regex_match_limit <num>*"
msgstr ""

#: ../../source/modules/lua.rst:1045
msgid "*lua_regex_match_limit 0*"
msgstr ""

#: ../../source/modules/lua.rst:1048
msgid ""
"Specifies the \"match limit\" used by the PCRE library when executing the "
"`ngx.re API <ngx.re.match_>`_. To quote the PCRE manpage, \"the limit ... "
"has the effect of limiting the amount of backtracking that can take place.\""
msgstr ""

#: ../../source/modules/lua.rst:1050
msgid ""
"When the limit is hit, the error string \"pcre_exec() failed: -8\" will be "
"returned by the `ngx.re API <ngx.re.match_>`_ functions on the Lua land."
msgstr ""

#: ../../source/modules/lua.rst:1052
msgid ""
"When setting the limit to 0, the default \"match limit\" when compiling the "
"PCRE library is used. And this is the default value of this directive."
msgstr ""

#: ../../source/modules/lua.rst:1054
msgid "This directive was first introduced in the ``v0.8.5`` release."
msgstr ""

#: ../../source/modules/lua.rst:1058
msgid "lua_package_path"
msgstr ""

#: ../../source/modules/lua.rst:1059
msgid "*lua_package_path <lua-style-path-str>*"
msgstr ""

#: ../../source/modules/lua.rst:1060
msgid ""
"*The content of LUA_PATH environ variable or Lua's compiled-in defaults.*"
msgstr ""

#: ../../source/modules/lua.rst:1063
msgid ""
"Sets the Lua module search path used by scripts specified by `set_by_lua`_, "
"`content_by_lua`_ and others. The path string is in standard Lua path form, "
"and ``;;`` can be used to stand for the original search paths."
msgstr ""

#: ../../source/modules/lua.rst:1065 ../../source/modules/lua.rst:1076
msgid ""
"As from the ``v0.5.0rc29`` release, the special notation ``$prefix`` or "
"``${prefix}`` can be used in the search path string to indicate the path of "
"the ``server prefix`` usually determined by the ``-p PATH`` command-line "
"option while starting the Nginx server."
msgstr ""

#: ../../source/modules/lua.rst:1069
msgid "lua_package_cpath"
msgstr ""

#: ../../source/modules/lua.rst:1070
msgid "*lua_package_cpath <lua-style-cpath-str>*"
msgstr ""

#: ../../source/modules/lua.rst:1071
msgid ""
"*The content of LUA_CPATH environment variable or Lua's compiled-in "
"defaults.*"
msgstr ""

#: ../../source/modules/lua.rst:1074
msgid ""
"Sets the Lua C-module search path used by scripts specified by "
"`set_by_lua`_, `content_by_lua`_ and others. The cpath string is in standard"
" Lua cpath form, and ``;;`` can be used to stand for the original cpath."
msgstr ""

#: ../../source/modules/lua.rst:1080
msgid "init_by_lua"
msgstr ""

#: ../../source/modules/lua.rst:1081
msgid "*init_by_lua <lua-script-str>*"
msgstr ""

#: ../../source/modules/lua.rst:1083 ../../source/modules/lua.rst:1150
msgid "*loading-config*"
msgstr ""

#: ../../source/modules/lua.rst:1085
msgid ""
"Runs the Lua code specified by the argument ``<lua-script-str>`` on the "
"global Lua VM level when the Nginx master process (if any) is loading the "
"Nginx config file."
msgstr ""

#: ../../source/modules/lua.rst:1087
msgid ""
"When Nginx receives the ``HUP`` signal and starts reloading the config file,"
" the Lua VM will also be re-created and ``init_by_lua`` will run again on "
"the new Lua VM. In case that the `lua_code_cache`_ directive is turned off "
"(default on), the ``init_by_lua`` handler will run upon every request "
"because in this special mode a standalone Lua VM is always created for each "
"request."
msgstr ""

#: ../../source/modules/lua.rst:1089
msgid ""
"Usually you can register (true) Lua global variables or pre-load Lua modules"
" at server start-up by means of this hook. Here is an example for pre-"
"loading Lua modules:"
msgstr ""

#: ../../source/modules/lua.rst:1105
msgid ""
"You can also initialize the `lua_shared_dict`_ shm storage at this phase. "
"Here is an example for this:"
msgstr ""

#: ../../source/modules/lua.rst:1126
msgid ""
"But note that, the `lua_shared_dict`_'s shm storage will not be cleared "
"through a config reload (via the ``HUP`` signal, for example). So if you do "
"*not* want to re-initialize the shm storage in your ``init_by_lua`` code in "
"this case, then you just need to set a custom flag in the shm storage and "
"always check the flag in your ``init_by_lua`` code."
msgstr ""

#: ../../source/modules/lua.rst:1128
msgid ""
"Because the Lua code in this context runs before Nginx forks its worker "
"processes (if any), data or code loaded here will enjoy the `Copy-on-write "
"(COW) <https://en.wikipedia.org/wiki/Copy-on-write>`_ feature provided by "
"many operating systems among all the worker processes, thus saving a lot of "
"memory."
msgstr ""

#: ../../source/modules/lua.rst:1130
msgid ""
"Do *not* initialize your own Lua global variables in this context because "
"use of Lua global variables have performance penalties and can lead to "
"global namespace pollution (see the `Lua Variable Scope <Lua Variable "
"Scope_>`_ section for more details). The recommended way is to use proper "
"`Lua module <http://www.lua.org/manual/5.1/manual.html#5.3>`_ files (but do "
"not use the standard Lua function `module() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-module>`_ to define Lua "
"modules because it pollutes the global namespace as well) and call "
"`require() <http://www.lua.org/manual/5.1/manual.html#pdf-require>`_ to load"
" your own module files in ``init_by_lua`` or other contexts (`require() "
"<http://www.lua.org/manual/5.1/manual.html#pdf-require>`_ does cache the "
"loaded Lua modules in the global ``package.loaded`` table in the Lua "
"registry so your modules will only loaded once for the whole Lua VM "
"instance)."
msgstr ""

#: ../../source/modules/lua.rst:1132
msgid ""
"Only a small set of the `Nginx API for Lua`_ is supported in this context:"
msgstr ""

#: ../../source/modules/lua.rst:1134
msgid "Logging APIs: `ngx.log`_ and `print`_,"
msgstr ""

#: ../../source/modules/lua.rst:1135
msgid "Shared Dictionary API: `ngx.shared.DICT`_."
msgstr ""

#: ../../source/modules/lua.rst:1137
msgid ""
"More Nginx APIs for Lua may be supported in this context upon future user "
"requests."
msgstr ""

#: ../../source/modules/lua.rst:1139
msgid ""
"Basically you can safely use Lua libraries that do blocking I/O in this very"
" context because blocking the master process during server start-up is "
"completely okay. Even the Nginx core does blocking I/O (at least on "
"resolving upstream's host names) at the configure-loading phase."
msgstr ""

#: ../../source/modules/lua.rst:1141
msgid ""
"You should be very careful about potential security vulnerabilities in your "
"Lua code registered in this context because the Nginx master process is "
"often run under the ``root`` account."
msgstr ""

#: ../../source/modules/lua.rst:1143 ../../source/modules/lua.rst:1156
msgid "This directive was first introduced in the ``v0.5.5`` release."
msgstr ""

#: ../../source/modules/lua.rst:1147
msgid "init_by_lua_file"
msgstr ""

#: ../../source/modules/lua.rst:1148
msgid "*init_by_lua_file <path-to-lua-script-file>*"
msgstr ""

#: ../../source/modules/lua.rst:1152
msgid ""
"Equivalent to `init_by_lua`_, except that the file specified by ``<path-to-"
"lua-script-file>`` contains the Lua code or `Lua/LuaJIT bytecode <Lua/LuaJIT"
" bytecode support_>`_ to be executed."
msgstr ""

#: ../../source/modules/lua.rst:1154 ../../source/modules/lua.rst:1277
#: ../../source/modules/lua.rst:1307 ../../source/modules/lua.rst:1459
#: ../../source/modules/lua.rst:1548 ../../source/modules/lua.rst:1593
#: ../../source/modules/lua.rst:1693 ../../source/modules/lua.rst:1767
msgid ""
"When a relative path like ``foo/bar.lua`` is given, they will be turned into"
" the absolute path relative to the ``server prefix`` path determined by the "
"``-p PATH`` command-line option while starting the Nginx server."
msgstr ""

#: ../../source/modules/lua.rst:1160
msgid "init_worker_by_lua"
msgstr ""

#: ../../source/modules/lua.rst:1161
msgid "*init_worker_by_lua <lua-script-str>*"
msgstr ""

#: ../../source/modules/lua.rst:1163 ../../source/modules/lua.rst:1204
msgid "*starting-worker*"
msgstr ""

#: ../../source/modules/lua.rst:1165
msgid ""
"Runs the specified Lua code upon every Nginx worker process's startup when "
"the master process is enabled. When the master process is disabled, this "
"hook will just run after `init_by_lua`_."
msgstr ""

#: ../../source/modules/lua.rst:1167
msgid ""
"This hook is often used to create per-worker reoccurring timers (via the "
"`ngx.timer.at`_ Lua API), either for backend healthcheck or other timed "
"routine work. Below is an example,"
msgstr ""

#: ../../source/modules/lua.rst:1197 ../../source/modules/lua.rst:1209
msgid "This directive was first introduced in the ``v0.9.5`` release."
msgstr ""

#: ../../source/modules/lua.rst:1201
msgid "init_worker_by_lua_file"
msgstr ""

#: ../../source/modules/lua.rst:1202
msgid "*init_worker_by_lua_file <lua-file-path>*"
msgstr ""

#: ../../source/modules/lua.rst:1206
msgid ""
"Similar to `init_worker_by_lua`_, but accepts the file path to a Lua source "
"file or Lua bytecode file."
msgstr ""

#: ../../source/modules/lua.rst:1213
msgid "set_by_lua"
msgstr ""

#: ../../source/modules/lua.rst:1214
msgid "*set_by_lua $res <lua-script-str> [$arg1 $arg2 ...]*"
msgstr ""

#: ../../source/modules/lua.rst:1215 ../../source/modules/lua.rst:1270
msgid "*server, server if, location, location if*"
msgstr ""

#: ../../source/modules/lua.rst:1216 ../../source/modules/lua.rst:1271
msgid "*rewrite*"
msgstr ""

#: ../../source/modules/lua.rst:1218
msgid ""
"Executes code specified in ``<lua-script-str>`` with optional input "
"arguments ``$arg1 $arg2 ...``, and returns string output to ``$res``."
msgstr ""

#: ../../source/modules/lua.rst:1220
msgid ""
"The code in ``<lua-script-str>`` can make `API calls <Nginx API for Lua>`_ "
"and can retrieve input arguments from the ``ngx.arg`` table (index starts "
"from ``1`` and increases sequentially)."
msgstr ""

#: ../../source/modules/lua.rst:1222
msgid ""
"This directive is designed to execute short, fast running code blocks as the"
" Nginx event loop is blocked during code execution. Time consuming code "
"sequences should therefore be avoided."
msgstr ""

#: ../../source/modules/lua.rst:1224
msgid ""
"This directive is implemented by injecting custom commands into the standard"
" |HttpRewriteModule|'s command list. Because |HttpRewriteModule| does not "
"support nonblocking I/O in its commands, Lua APIs requiring yielding the "
"current Lua \"light thread\" cannot work in this directive."
msgstr ""

#: ../../source/modules/lua.rst:1226
msgid ""
"At least the following API functions are currently disabled within the "
"context of ``set_by_lua``:"
msgstr ""

#: ../../source/modules/lua.rst:1228 ../../source/modules/lua.rst:1567
#: ../../source/modules/lua.rst:1675 ../../source/modules/lua.rst:1708
msgid "Output API functions (e.g., `ngx.say`_ and `ngx.send_headers`_)"
msgstr ""

#: ../../source/modules/lua.rst:1229 ../../source/modules/lua.rst:1709
msgid "Control API functions (e.g., `ngx.exit`_)"
msgstr ""

#: ../../source/modules/lua.rst:1230 ../../source/modules/lua.rst:1569
#: ../../source/modules/lua.rst:1677 ../../source/modules/lua.rst:1710
msgid ""
"Subrequest API functions (e.g., `ngx.location.capture`_ and "
"`ngx.location.capture_multi`_)"
msgstr ""

#: ../../source/modules/lua.rst:1231 ../../source/modules/lua.rst:1570
#: ../../source/modules/lua.rst:1678 ../../source/modules/lua.rst:1711
msgid ""
"Cosocket API functions (e.g., `ngx.socket.tcp`_ and `ngx.req.socket`_)."
msgstr ""

#: ../../source/modules/lua.rst:1232
msgid "Sleeping API function `ngx.sleep`_."
msgstr ""

#: ../../source/modules/lua.rst:1234
msgid ""
"In addition, note that this directive can only write out a value to a single"
" Nginx variable at a time. However, a workaround is possible using the "
"`ngx.var.VARIABLE`_ interface."
msgstr ""

#: ../../source/modules/lua.rst:1253
msgid ""
"This directive can be freely mixed with all directives of the "
"|HttpRewriteModule|, :doc:`set_misc`, and :github:`HttpArrayVarModule "
"<openresty/array-var-nginx-module>` modules. All of these directives will "
"run in the same order as they appear in the config file."
msgstr ""

#: ../../source/modules/lua.rst:1262
msgid ""
"As from the ``v0.5.0rc29`` release, Nginx variable interpolation is disabled"
" in the ``<lua-script-str>`` argument of this directive and therefore, the "
"dollar sign character (``$``) can be used directly."
msgstr ""

#: ../../source/modules/lua.rst:1264 ../../source/modules/lua.rst:1281
msgid ""
"This directive requires the :github:`ngx_devel_kit <simpl/ngx_devel_kit>` "
"module."
msgstr ""

#: ../../source/modules/lua.rst:1268
msgid "set_by_lua_file"
msgstr ""

#: ../../source/modules/lua.rst:1269
msgid "*set_by_lua_file $res <path-to-lua-script-file> [$arg1 $arg2 ...]*"
msgstr ""

#: ../../source/modules/lua.rst:1273
msgid ""
"Equivalent to `set_by_lua`_, except that the file specified by ``<path-to-"
"lua-script-file>`` contains the Lua code, or, as from the ``v0.5.0rc32`` "
"release, the `Lua/LuaJIT bytecode <Lua/LuaJIT bytecode support_>`_ to be "
"executed."
msgstr ""

#: ../../source/modules/lua.rst:1275
msgid ""
"Nginx variable interpolation is supported in the ``<path-to-lua-script-"
"file>`` argument string of this directive. But special care must be taken "
"for injection attacks."
msgstr ""

#: ../../source/modules/lua.rst:1279 ../../source/modules/lua.rst:1309
msgid ""
"When the Lua code cache is turned on (by default), the user code is loaded "
"once at the first request and cachedand the Nginx config must be reloaded "
"each time the Lua source file is modified.The Lua code cache can be "
"temporarily disabled during development byswitching `lua_code_cache`_ "
"``off`` in ``nginx.conf`` to avoid reloading Nginx."
msgstr ""

#: ../../source/modules/lua.rst:1285
msgid "content_by_lua"
msgstr ""

#: ../../source/modules/lua.rst:1286
msgid "*content_by_lua <lua-script-str>*"
msgstr ""

#: ../../source/modules/lua.rst:1287 ../../source/modules/lua.rst:1300
msgid "*location, location if*"
msgstr ""

#: ../../source/modules/lua.rst:1288 ../../source/modules/lua.rst:1301
msgid "*content*"
msgstr ""

#: ../../source/modules/lua.rst:1290
msgid ""
"Acts as a \"content handler\" and executes Lua code string specified in "
"``<lua-script-str>`` for every request."
msgstr ""

#: ../../source/modules/lua.rst:1292 ../../source/modules/lua.rst:1334
#: ../../source/modules/lua.rst:1476
msgid ""
"The Lua code may make `API calls <Nginx API for Lua_>`_ and is executed as a"
" new spawned coroutine in an independent global environment (i.e. a "
"sandbox)."
msgstr ""

#: ../../source/modules/lua.rst:1294
msgid ""
"Do not use this directive and other content handler directives in the same "
"location. For example, this directive and the `proxy_pass "
"<|HttpProxyModule|#proxy_pass>`_ directive should not be used in the same "
"location."
msgstr ""

#: ../../source/modules/lua.rst:1298
msgid "content_by_lua_file"
msgstr ""

#: ../../source/modules/lua.rst:1299
msgid "*content_by_lua_file <path-to-lua-script-file>*"
msgstr ""

#: ../../source/modules/lua.rst:1303
msgid ""
"Equivalent to `content_by_lua`_, except that the file specified by ``<path-"
"to-lua-script-file>`` contains the Lua code, or, as from the ``v0.5.0rc32`` "
"release, the `Lua/LuaJIT bytecode <Lua/LuaJIT bytecode support_>`_ to be "
"executed."
msgstr ""

#: ../../source/modules/lua.rst:1305 ../../source/modules/lua.rst:1457
#: ../../source/modules/lua.rst:1546
msgid ""
"Nginx variables can be used in the ``<path-to-lua-script-file>`` string to "
"provide flexibility. This however carries some risks and is not ordinarily "
"recommended."
msgstr ""

#: ../../source/modules/lua.rst:1311
msgid ""
"Nginx variables are supported in the file path for dynamic dispatch, for "
"example:"
msgstr ""

#: ../../source/modules/lua.rst:1323
msgid ""
"But be very careful about malicious user inputs and always carefully "
"validate or filter out the user-supplied path components."
msgstr ""

#: ../../source/modules/lua.rst:1327
msgid "rewrite_by_lua"
msgstr ""

#: ../../source/modules/lua.rst:1328
msgid "*rewrite_by_lua <lua-script-str>*"
msgstr ""

#: ../../source/modules/lua.rst:1330 ../../source/modules/lua.rst:1453
msgid "*rewrite tail*"
msgstr ""

#: ../../source/modules/lua.rst:1332
msgid ""
"Acts as a rewrite phase handler and executes Lua code string specified in "
"``<lua-script-str>`` for every request."
msgstr ""

#: ../../source/modules/lua.rst:1336
msgid ""
"Note that this handler always runs *after* the standard |HttpRewriteModule|."
" So the following will work as expected:"
msgstr ""

#: ../../source/modules/lua.rst:1349
msgid "because ``set $a 12`` and ``set $b \"\"`` run *before* `rewrite_by_lua`_."
msgstr ""

#: ../../source/modules/lua.rst:1351
msgid "On the other hand, the following will not work as expected:"
msgstr ""

#: ../../source/modules/lua.rst:1368
msgid ""
"because ``if`` runs *before* `rewrite_by_lua`_ even if it is placed after "
"`rewrite_by_lua`_ in the config."
msgstr ""

#: ../../source/modules/lua.rst:1370
msgid "The right way of doing this is as follows:"
msgstr ""

#: ../../source/modules/lua.rst:1389
msgid ""
"Note that the `ngx_eval <http://www.grid.net.ru/nginx/eval.en.html>`__ "
"module can be approximated by using `rewrite_by_lua`_. For example,"
msgstr ""

#: ../../source/modules/lua.rst:1406 ../../source/modules/lua.rst:1510
msgid "can be implemented in ngx_lua as:"
msgstr ""

#: ../../source/modules/lua.rst:1427
msgid ""
"Just as any other rewrite phase handlers, `rewrite_by_lua`_ also runs in "
"subrequests."
msgstr ""

#: ../../source/modules/lua.rst:1429
msgid ""
"Note that when calling ``ngx.exit(ngx.OK)`` within a `rewrite_by_lua`_ "
"handler, the nginx request processing control flow will still continue to "
"the content handler. To terminate the current request from within a "
"`rewrite_by_lua`_ handler, calling `ngx.exit`_ with status >= 200 "
"(``ngx.HTTP_OK``) and status < 300 (``ngx.HTTP_SPECIAL_RESPONSE``) for "
"successful quits and ``ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)`` (or its "
"friends) for failures."
msgstr ""

#: ../../source/modules/lua.rst:1431
msgid ""
"If the |HttpRewriteModule|'s `rewrite <|HttpRewriteModule|#rewrite>`_ "
"directive is used to change the URI and initiate location re-lookups "
"(internal redirections), then any `rewrite_by_lua`_ or "
"`rewrite_by_lua_file`_ code sequences within the current location will not "
"be executed. For example,"
msgstr ""

#: ../../source/modules/lua.rst:1444
msgid ""
"Here the Lua code ``ngx.exit(503)`` will never run. This will be the case if"
" ``rewrite ^ /bar last`` is used as this will similarly initiate an internal"
" redirection. If the ``break`` modifier is used instead, there will be no "
"internal redirection and the ``rewrite_by_lua`` code will be executed."
msgstr ""

#: ../../source/modules/lua.rst:1446
msgid ""
"The ``rewrite_by_lua`` code will always run at the end of the ``rewrite`` "
"request-processing phase unless `rewrite_by_lua_no_postpone`_ is turned on."
msgstr ""

#: ../../source/modules/lua.rst:1450
msgid "rewrite_by_lua_file"
msgstr ""

#: ../../source/modules/lua.rst:1451
msgid "*rewrite_by_lua_file <path-to-lua-script-file>*"
msgstr ""

#: ../../source/modules/lua.rst:1455
msgid ""
"Equivalent to `rewrite_by_lua`_, except that the file specified by ``<path-"
"to-lua-script-file>`` contains the Lua code, or, as from the ``v0.5.0rc32`` "
"release, the `Lua/LuaJIT bytecode <Lua/LuaJIT bytecode support_>`_ to be "
"executed."
msgstr ""

#: ../../source/modules/lua.rst:1461
msgid ""
"When the Lua code cache is turned on (by default), the user code is loaded "
"once at the first request and cached and the Nginx config must be reloaded "
"each time the Lua source file is modified. The Lua code cache can be "
"temporarily disabled during development by switching `lua_code_cache`_ "
"``off`` in ``nginx.conf`` to avoid reloading Nginx."
msgstr ""

#: ../../source/modules/lua.rst:1463
msgid ""
"The ``rewrite_by_lua_file`` code will always run at the end of the "
"``rewrite`` request-processing phase unless `rewrite_by_lua_no_postpone`_ is"
" turned on."
msgstr ""

#: ../../source/modules/lua.rst:1465 ../../source/modules/lua.rst:1554
msgid ""
"Nginx variables are supported in the file path for dynamic dispatch just as "
"in `content_by_lua_file`_."
msgstr ""

#: ../../source/modules/lua.rst:1469
msgid "access_by_lua"
msgstr ""

#: ../../source/modules/lua.rst:1470
msgid "*access_by_lua <lua-script-str>*"
msgstr ""

#: ../../source/modules/lua.rst:1472 ../../source/modules/lua.rst:1542
msgid "*access tail*"
msgstr ""

#: ../../source/modules/lua.rst:1474
msgid ""
"Acts as an access phase handler and executes Lua code string specified in "
"``<lua-script-str>`` for every request."
msgstr ""

#: ../../source/modules/lua.rst:1478
msgid ""
"Note that this handler always runs *after* the standard |HttpAccessModule|. "
"So the following will work as expected:"
msgstr ""

#: ../../source/modules/lua.rst:1497
msgid ""
"That is, if a client IP address is in the blacklist, it will be denied "
"before the MySQL query for more complex authentication is executed by "
"`access_by_lua`_."
msgstr ""

#: ../../source/modules/lua.rst:1499
msgid ""
"The `ngx_auth_request "
"<http://mdounin.ru/hg/ngx_http_auth_request_module/>`__ module can be "
"approximated by using `access_by_lua`_:"
msgstr ""

#: ../../source/modules/lua.rst:1533
msgid ""
"As with other access phase handlers, `access_by_lua`_ will *not* run in "
"subrequests."
msgstr ""

#: ../../source/modules/lua.rst:1535
msgid ""
"When calling ``ngx.exit(ngx.OK)`` within a `access_by_lua`_ handler, the "
"nginx request processing control flow will still continue to the content "
"handler. To terminate the current request from within a `access_by_lua`_ "
"handler, calling `ngx.exit`_ with status >= 200 (``ngx.HTTP_OK``) and status"
" < 300 (``ngx.HTTP_SPECIAL_RESPONSE``) for successful quits and "
"``ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)`` (or its friends) for failures."
msgstr ""

#: ../../source/modules/lua.rst:1539
msgid "access_by_lua_file"
msgstr ""

#: ../../source/modules/lua.rst:1540
msgid "*access_by_lua_file <path-to-lua-script-file>*"
msgstr ""

#: ../../source/modules/lua.rst:1544
msgid ""
"Equivalent to `access_by_lua`_, except that the file specified by ``<path-"
"to-lua-script-file>`` contains the Lua code, or, as from the ``v0.5.0rc32`` "
"release, the `Lua/LuaJIT bytecode <Lua/LuaJIT bytecode support_>`_ to be "
"executed."
msgstr ""

#: ../../source/modules/lua.rst:1550
msgid ""
"When the Lua code cache is turned on (by default), the user code is loaded "
"once at the first request and cached and the Nginx config must be reloaded "
"each time the Lua source file is modified."
msgstr ""

#: ../../source/modules/lua.rst:1552
msgid ""
"The Lua code cache can be temporarily disabled during development by "
"switching `lua_code_cache`_ ``off`` in ``nginx.conf`` to avoid repeatedly "
"reloading Nginx."
msgstr ""

#: ../../source/modules/lua.rst:1558
msgid "header_filter_by_lua"
msgstr ""

#: ../../source/modules/lua.rst:1559
msgid "*header_filter_by_lua <lua-script-str>*"
msgstr ""

#: ../../source/modules/lua.rst:1561 ../../source/modules/lua.rst:1589
msgid "*output-header-filter*"
msgstr ""

#: ../../source/modules/lua.rst:1563
msgid ""
"Uses Lua code specified in ``<lua-script-str>`` to define an output header "
"filter."
msgstr ""

#: ../../source/modules/lua.rst:1565
msgid ""
"Note that the following API functions are currently disabled within this "
"context:"
msgstr ""

#: ../../source/modules/lua.rst:1568 ../../source/modules/lua.rst:1676
msgid "Control API functions (e.g., `ngx.exit`_ and `ngx.exec`_)"
msgstr ""

#: ../../source/modules/lua.rst:1572
msgid ""
"Here is an example of overriding a response header (or adding one if absent)"
" in our Lua header filter:"
msgstr ""

#: ../../source/modules/lua.rst:1582 ../../source/modules/lua.rst:1595
msgid "This directive was first introduced in the ``v0.2.1rc20`` release."
msgstr ""

#: ../../source/modules/lua.rst:1586
msgid "header_filter_by_lua_file"
msgstr ""

#: ../../source/modules/lua.rst:1587
msgid "*header_filter_by_lua_file <path-to-lua-script-file>*"
msgstr ""

#: ../../source/modules/lua.rst:1591
msgid ""
"Equivalent to `header_filter_by_lua`_, except that the file specified by "
"``<path-to-lua-script-file>`` contains the Lua code, or as from the "
"``v0.5.0rc32`` release, the `Lua/LuaJIT bytecode <Lua/LuaJIT bytecode "
"support_>`_ to be executed."
msgstr ""

#: ../../source/modules/lua.rst:1599
msgid "body_filter_by_lua"
msgstr ""

#: ../../source/modules/lua.rst:1600
msgid "*body_filter_by_lua <lua-script-str>*"
msgstr ""

#: ../../source/modules/lua.rst:1602 ../../source/modules/lua.rst:1689
msgid "*output-body-filter*"
msgstr ""

#: ../../source/modules/lua.rst:1604
msgid ""
"Uses Lua code specified in ``<lua-script-str>`` to define an output body "
"filter."
msgstr ""

#: ../../source/modules/lua.rst:1606
msgid ""
"The input data chunk is passed via `ngx.arg`_\\ [1] (as a Lua string value) "
"and the \"eof\" flag indicating the end of the response body data stream is "
"passed via `ngx.arg`_\\ [2] (as a Lua boolean value)."
msgstr ""

#: ../../source/modules/lua.rst:1608
msgid ""
"Behind the scene, the \"eof\" flag is just the ``last_buf`` (for main "
"requests) or ``last_in_chain`` (for subrequests) flag of the Nginx chain "
"link buffers. (Before the ``v0.7.14`` release, the \"eof\" flag does not "
"work at all in subrequests.)"
msgstr ""

#: ../../source/modules/lua.rst:1610
msgid ""
"The output data stream can be aborted immediately by running the following "
"Lua statement:"
msgstr ""

#: ../../source/modules/lua.rst:1617
msgid ""
"This will truncate the response body and usually result in incomplete and "
"also invalid responses."
msgstr ""

#: ../../source/modules/lua.rst:1619
msgid ""
"The Lua code can pass its own modified version of the input data chunk to "
"the downstream Nginx output body filters by overriding `ngx.arg`_\\ [1] with"
" a Lua string or a Lua table of strings. For example, to transform all the "
"lowercase letters in the response body, we can just write:"
msgstr ""

#: ../../source/modules/lua.rst:1629
msgid ""
"When setting ``nil`` or an empty Lua string value to ``ngx.arg[1]``, no data"
" chunk will be passed to the downstream Nginx output filters at all."
msgstr ""

#: ../../source/modules/lua.rst:1631
msgid ""
"Likewise, new \"eof\" flag can also be specified by setting a boolean value "
"to `ngx.arg`_\\ [2]. For example,"
msgstr ""

#: ../../source/modules/lua.rst:1652
msgid "Then ``GET /t`` will just return the output"
msgstr ""

#: ../../source/modules/lua.rst:1659
msgid ""
"That is, when the body filter sees a chunk containing the word \"hello\", "
"then it will set the \"eof\" flag to true immediately, resulting in "
"truncated but still valid responses."
msgstr ""

#: ../../source/modules/lua.rst:1661
msgid ""
"When the Lua code may change the length of the response body, then it is "
"required to always clear out the ``Content-Length`` response header (if any)"
" in a header filter to enforce streaming output, as in"
msgstr ""

#: ../../source/modules/lua.rst:1673
msgid ""
"Note that the following API functions are currently disabled within this "
"context due to the limitations in NGINX output filter's current "
"implementation:"
msgstr ""

#: ../../source/modules/lua.rst:1680
msgid ""
"Nginx output filters may be called multiple times for a single request "
"because response body may be delivered in chunks. Thus, the Lua code "
"specified by in this directive may also run multiple times in the lifetime "
"of a single HTTP request."
msgstr ""

#: ../../source/modules/lua.rst:1682 ../../source/modules/lua.rst:1695
#: ../../source/modules/lua.rst:2018
msgid "This directive was first introduced in the ``v0.5.0rc32`` release."
msgstr ""

#: ../../source/modules/lua.rst:1686
msgid "body_filter_by_lua_file"
msgstr ""

#: ../../source/modules/lua.rst:1687
msgid "*body_filter_by_lua_file <path-to-lua-script-file>*"
msgstr ""

#: ../../source/modules/lua.rst:1691
msgid ""
"Equivalent to `body_filter_by_lua`_, except that the file specified by "
"``<path-to-lua-script-file>`` contains the Lua code, or, as from the "
"``v0.5.0rc32`` release, the `Lua/LuaJIT bytecode <Lua/LuaJIT bytecode "
"support_>`_ to be executed."
msgstr ""

#: ../../source/modules/lua.rst:1699
msgid "log_by_lua"
msgstr ""

#: ../../source/modules/lua.rst:1700
msgid "*log_by_lua <lua-script-str>*"
msgstr ""

#: ../../source/modules/lua.rst:1702 ../../source/modules/lua.rst:1763
msgid "*log*"
msgstr ""

#: ../../source/modules/lua.rst:1704
msgid ""
"Run the Lua source code inlined as the ``<lua-script-str>`` at the ``log`` "
"request processing phase. This does not replace the current access logs, but"
" runs after."
msgstr ""

#: ../../source/modules/lua.rst:1706
msgid ""
"The following API functions are currently disabled within this context:"
msgstr ""

#: ../../source/modules/lua.rst:1713
msgid ""
"Here is an example of gathering average data for `$upstream_response_time "
"<|HttpUpstreamModule|#$upstream_response_time>`_:"
msgstr ""

#: ../../source/modules/lua.rst:1756 ../../source/modules/lua.rst:1769
msgid "This directive was first introduced in the ``v0.5.0rc31`` release."
msgstr ""

#: ../../source/modules/lua.rst:1760
msgid "log_by_lua_file"
msgstr ""

#: ../../source/modules/lua.rst:1761
msgid "*log_by_lua_file <path-to-lua-script-file>*"
msgstr ""

#: ../../source/modules/lua.rst:1765
msgid ""
"Equivalent to `log_by_lua`_, except that the file specified by ``<path-to-"
"lua-script-file>`` contains the Lua code, or, as from the ``v0.5.0rc32`` "
"release, the `Lua/LuaJIT bytecode <Lua/LuaJIT bytecode support_>`_ to be "
"executed."
msgstr ""

#: ../../source/modules/lua.rst:1773
msgid "lua_need_request_body"
msgstr ""

#: ../../source/modules/lua.rst:1774
msgid "*lua_need_request_body <on|off>*"
msgstr ""

#: ../../source/modules/lua.rst:1775
msgid "*off*"
msgstr ""

#: ../../source/modules/lua.rst:1777 ../../source/modules/lua.rst:1795
#: ../../source/modules/lua.rst:1857
msgid "*depends on usage*"
msgstr ""

#: ../../source/modules/lua.rst:1779
msgid ""
"Determines whether to force the request body data to be read before running "
"rewrite/access/access_by_lua or not. The Nginx core does not read the client"
" request body by default and if request body data is required, then this "
"directive should be turned ``on`` or the `ngx.req.read_body`_ function "
"should be called within the Lua code."
msgstr ""

#: ../../source/modules/lua.rst:1781
msgid ""
"To read the request body data within the `$request_body "
"<|HttpCoreModule|#$request_body>`_ variable, `client_body_buffer_size "
"<|HttpCoreModule|#client_body_buffer_size>`_ must have the same value as "
"`client_max_body_size <|HttpCoreModule|#client_max_body_size>`_. Because "
"when the content length exceeds `client_body_buffer_size "
"<|HttpCoreModule|#client_body_buffer_size>`_ but less than "
"`client_max_body_size <|HttpCoreModule|#client_max_body_size>`_, Nginx will "
"buffer the data into a temporary file on the disk, which will lead to empty "
"value in the `$request_body <|HttpCoreModule|#$request_body>`_ variable."
msgstr ""

#: ../../source/modules/lua.rst:1783
msgid ""
"If the current location includes `rewrite_by_lua`_ or `rewrite_by_lua_file`_"
" directives,then the request body will be read just before the "
"`rewrite_by_lua`_ or `rewrite_by_lua_file`_ code is run (and also at "
"the``rewrite`` phase). Similarly, if only `content_by_lua`_ is specified,the"
" request body will not be read until the content handler's Lua code isabout "
"to run (i.e., the request body will be read during the content phase)."
msgstr ""

#: ../../source/modules/lua.rst:1785
msgid ""
"It is recommended however, to use the `ngx.req.read_body`_ and "
"`ngx.req.discard_body`_ functions for finer control over the request body "
"reading process instead."
msgstr ""

#: ../../source/modules/lua.rst:1787
msgid "This also applies to `access_by_lua`_ and `access_by_lua_file`_."
msgstr ""

#: ../../source/modules/lua.rst:1791
msgid "lua_shared_dict"
msgstr ""

#: ../../source/modules/lua.rst:1792
msgid "*lua_shared_dict <name> <size>*"
msgstr ""

#: ../../source/modules/lua.rst:1793 ../../source/modules/lua.rst:1937
#: ../../source/modules/lua.rst:1959
msgid "*no*"
msgstr ""

#: ../../source/modules/lua.rst:1797
msgid ""
"Declares a shared memory zone, ``<name>``, to serve as storage for the shm "
"based Lua dictionary ``ngx.shared.<name>``."
msgstr ""

#: ../../source/modules/lua.rst:1799 ../../source/modules/lua.rst:4662
msgid ""
"Shared memory zones are always shared by all the nginx worker processes in "
"the current nginx server instance."
msgstr ""

#: ../../source/modules/lua.rst:1801
msgid "The ``<size>`` argument accepts size units such as ``k`` and ``m``:"
msgstr ""

#: ../../source/modules/lua.rst:1811
msgid "See `ngx.shared.DICT`_ for details."
msgstr ""

#: ../../source/modules/lua.rst:1813
msgid "This directive was first introduced in the ``v0.3.1rc22`` release."
msgstr ""

#: ../../source/modules/lua.rst:1817
msgid "lua_socket_connect_timeout"
msgstr ""

#: ../../source/modules/lua.rst:1818
msgid "*lua_socket_connect_timeout <time>*"
msgstr ""

#: ../../source/modules/lua.rst:1819
msgid "*lua_socket_connect_timeout 60s*"
msgstr ""

#: ../../source/modules/lua.rst:1820 ../../source/modules/lua.rst:1833
#: ../../source/modules/lua.rst:1847 ../../source/modules/lua.rst:1856
#: ../../source/modules/lua.rst:1871 ../../source/modules/lua.rst:1884
#: ../../source/modules/lua.rst:1901 ../../source/modules/lua.rst:1914
#: ../../source/modules/lua.rst:1925 ../../source/modules/lua.rst:1938
#: ../../source/modules/lua.rst:1949 ../../source/modules/lua.rst:1960
#: ../../source/modules/lua.rst:1973
msgid "*http, server, location*"
msgstr ""

#: ../../source/modules/lua.rst:1822
msgid ""
"This directive controls the default timeout value used in TCP/unix-domain "
"socket object's `connect <tcpsock:connect_>`_ method and can be overridden "
"by the `settimeout <tcpsock:settimeout_>`__ method."
msgstr ""

#: ../../source/modules/lua.rst:1824 ../../source/modules/lua.rst:1837
#: ../../source/modules/lua.rst:1861 ../../source/modules/lua.rst:1905
msgid ""
"The ``<time>`` argument can be an integer, with an optional time unit, like "
"``s`` (second), ``ms`` (millisecond), ``m`` (minute). The default time unit "
"is ``s``, i.e., \"second\". The default setting is ``60s``."
msgstr ""

#: ../../source/modules/lua.rst:1826 ../../source/modules/lua.rst:1840
#: ../../source/modules/lua.rst:1864 ../../source/modules/lua.rst:1877
#: ../../source/modules/lua.rst:1894 ../../source/modules/lua.rst:1907
msgid "This directive was first introduced in the ``v0.5.0rc1`` release."
msgstr ""

#: ../../source/modules/lua.rst:1830
msgid "lua_socket_send_timeout"
msgstr ""

#: ../../source/modules/lua.rst:1831
msgid "*lua_socket_send_timeout <time>*"
msgstr ""

#: ../../source/modules/lua.rst:1832
msgid "*lua_socket_send_timeout 60s*"
msgstr ""

#: ../../source/modules/lua.rst:1835
msgid ""
"Controls the default timeout value used in TCP/unix-domain socket object's "
"`send <tcpsock:send_>`__ method and can be overridden by the `settimeout "
"<tcpsock:settimeout_>`__ method."
msgstr ""

#: ../../source/modules/lua.rst:1844
msgid "lua_socket_send_lowat"
msgstr ""

#: ../../source/modules/lua.rst:1845
msgid "*lua_socket_send_lowat <size>*"
msgstr ""

#: ../../source/modules/lua.rst:1846
msgid "*lua_socket_send_lowat 0*"
msgstr ""

#: ../../source/modules/lua.rst:1849
msgid "Controls the ``lowat`` (low water) value for the cosocket send buffer."
msgstr ""

#: ../../source/modules/lua.rst:1853
msgid "lua_socket_read_timeout"
msgstr ""

#: ../../source/modules/lua.rst:1854
msgid "*lua_socket_read_timeout <time>*"
msgstr ""

#: ../../source/modules/lua.rst:1855
msgid "*lua_socket_read_timeout 60s*"
msgstr ""

#: ../../source/modules/lua.rst:1859
msgid ""
"This directive controls the default timeout value used in TCP/unix-domain "
"socket object's `receive <tcpsock:receive_>`__ method and iterator functions"
" returned by the `receiveuntil <tcpsock:receiveuntil_>`_ method. This "
"setting can be overridden by the `settimeout <tcpsock:settimeout_>`__ "
"method."
msgstr ""

#: ../../source/modules/lua.rst:1868
msgid "lua_socket_buffer_size"
msgstr ""

#: ../../source/modules/lua.rst:1869
msgid "*lua_socket_buffer_size <size>*"
msgstr ""

#: ../../source/modules/lua.rst:1870
msgid "*lua_socket_buffer_size 4k/8k*"
msgstr ""

#: ../../source/modules/lua.rst:1873
msgid "Specifies the buffer size used by cosocket reading operations."
msgstr ""

#: ../../source/modules/lua.rst:1875
msgid ""
"This buffer does not have to be that big to hold everything at the same time"
" because cosocket supports 100% non-buffered reading and parsing. So even "
"``1`` byte buffer size should still work everywhere but the performance "
"could be terrible."
msgstr ""

#: ../../source/modules/lua.rst:1881
msgid "lua_socket_pool_size"
msgstr ""

#: ../../source/modules/lua.rst:1882
msgid "*lua_socket_pool_size <size>*"
msgstr ""

#: ../../source/modules/lua.rst:1883
msgid "*lua_socket_pool_size 30*"
msgstr ""

#: ../../source/modules/lua.rst:1886
msgid ""
"Specifies the size limit (in terms of connection count) for every cosocket "
"connection pool associated with every remote server (i.e., identified by "
"either the host-port pair or the unix domain socket file path)."
msgstr ""

#: ../../source/modules/lua.rst:1888
msgid "Default to 30 connections for every pool."
msgstr ""

#: ../../source/modules/lua.rst:1890 ../../source/modules/lua.rst:5429
msgid ""
"When the connection pool exceeds the available size limit, the least "
"recently used (idle) connection already in the pool will be closed to make "
"room for the current connection."
msgstr ""

#: ../../source/modules/lua.rst:1892
msgid ""
"Note that the cosocket connection pool is per nginx worker process rather "
"than per nginx server instance, so size limit specified here also applies to"
" every single nginx worker process."
msgstr ""

#: ../../source/modules/lua.rst:1898
msgid "lua_socket_keepalive_timeout"
msgstr ""

#: ../../source/modules/lua.rst:1899
msgid "*lua_socket_keepalive_timeout <time>*"
msgstr ""

#: ../../source/modules/lua.rst:1900
msgid "*lua_socket_keepalive_timeout 60s*"
msgstr ""

#: ../../source/modules/lua.rst:1903
msgid ""
"This directive controls the default maximal idle time of the connections in "
"the cosocket built-in connection pool. When this timeout reaches, idle "
"connections will be closed and removed from the pool. This setting can be "
"overridden by cosocket objects' `setkeepalive <tcpsock:setkeepalive_>`_ "
"method."
msgstr ""

#: ../../source/modules/lua.rst:1911
msgid "lua_socket_log_errors"
msgstr ""

#: ../../source/modules/lua.rst:1912
msgid "*lua_socket_log_errors on|off*"
msgstr ""

#: ../../source/modules/lua.rst:1913
msgid "*lua_socket_log_errors on*"
msgstr ""

#: ../../source/modules/lua.rst:1916
msgid ""
"This directive can be used to toggle error logging when a failure occurs for"
" the TCP or UDP cosockets. If you are already doing proper error handling "
"and logging in your Lua code, then it is recommended to turn this directive "
"off to prevent data flushing in your nginx error log files (which is usually"
" rather expensive)."
msgstr ""

#: ../../source/modules/lua.rst:1918
msgid "This directive was first introduced in the ``v0.5.13`` release."
msgstr ""

#: ../../source/modules/lua.rst:1922
msgid "lua_ssl_ciphers"
msgstr ""

#: ../../source/modules/lua.rst:1923
msgid "*lua_ssl_ciphers <ciphers>*"
msgstr ""

#: ../../source/modules/lua.rst:1924
msgid "*lua_ssl_ciphers DEFAULT*"
msgstr ""

#: ../../source/modules/lua.rst:1927
msgid ""
"Specifies the enabled ciphers for requests to a SSL/TLS server in the "
"`tcpsock:sslhandshake`_ method. The ciphers are specified in the format "
"understood by the OpenSSL library."
msgstr ""

#: ../../source/modules/lua.rst:1929
msgid "The full list can be viewed using the “openssl ciphers” command."
msgstr ""

#: ../../source/modules/lua.rst:1931 ../../source/modules/lua.rst:1942
#: ../../source/modules/lua.rst:1953 ../../source/modules/lua.rst:1964
#: ../../source/modules/lua.rst:1977
msgid "This directive was first introduced in the ``v0.9.11`` release."
msgstr ""

#: ../../source/modules/lua.rst:1935
msgid "lua_ssl_crl"
msgstr ""

#: ../../source/modules/lua.rst:1936
msgid "*lua_ssl_crl <file>*"
msgstr ""

#: ../../source/modules/lua.rst:1940
msgid ""
"Specifies a file with revoked certificates (CRL) in the PEM format used to "
"verify the certificate of the SSL/TLS server in the `tcpsock:sslhandshake`_ "
"method."
msgstr ""

#: ../../source/modules/lua.rst:1946
msgid "lua_ssl_protocols"
msgstr ""

#: ../../source/modules/lua.rst:1947
msgid "*lua_ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2]*"
msgstr ""

#: ../../source/modules/lua.rst:1948
msgid "*lua_ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2*"
msgstr ""

#: ../../source/modules/lua.rst:1951
msgid ""
"Enables the specified protocols for requests to a SSL/TLS server in the "
"`tcpsock:sslhandshake`_ method."
msgstr ""

#: ../../source/modules/lua.rst:1957
msgid "lua_ssl_trusted_certificate"
msgstr ""

#: ../../source/modules/lua.rst:1958
msgid "*lua_ssl_trusted_certificate <file>*"
msgstr ""

#: ../../source/modules/lua.rst:1962
msgid ""
"Specifies a file path with trusted CA certificates in the PEM format used to"
" verify the certificate of the SSL/TLS server in the `tcpsock:sslhandshake`_"
" method."
msgstr ""

#: ../../source/modules/lua.rst:1966
msgid "`lua_ssl_verify_depth`_."
msgstr ""

#: ../../source/modules/lua.rst:1970
msgid "lua_ssl_verify_depth"
msgstr ""

#: ../../source/modules/lua.rst:1971
msgid "*lua_ssl_verify_depth <number>*"
msgstr ""

#: ../../source/modules/lua.rst:1972
msgid "*lua_ssl_verify_depth 1*"
msgstr ""

#: ../../source/modules/lua.rst:1975
msgid "Sets the verification depth in the server certificates chain."
msgstr ""

#: ../../source/modules/lua.rst:1979
msgid "`lua_ssl_trusted_certificate`_."
msgstr ""

#: ../../source/modules/lua.rst:1983
msgid "lua_http10_buffering"
msgstr ""

#: ../../source/modules/lua.rst:1984
msgid "*lua_http10_buffering on|off*"
msgstr ""

#: ../../source/modules/lua.rst:1985
msgid "*lua_http10_buffering on*"
msgstr ""

#: ../../source/modules/lua.rst:1986 ../../source/modules/lua.rst:2014
#: ../../source/modules/lua.rst:2025
msgid "*http, server, location, location-if*"
msgstr ""

#: ../../source/modules/lua.rst:1988
msgid ""
"Enables or disables automatic response buffering for HTTP 1.0 (or older) "
"requests. This buffering mechanism is mainly used for HTTP 1.0 keep-alive "
"which replies on a proper ``Content-Length`` response header."
msgstr ""

#: ../../source/modules/lua.rst:1990
msgid ""
"If the Lua code explicitly sets a ``Content-Length`` response header before "
"sending the headers (either explicitly via `ngx.send_headers`_ or implicitly"
" via the first `ngx.say`_ or `ngx.print`_ call), then the HTTP 1.0 response "
"buffering will be disabled even when this directive is turned on."
msgstr ""

#: ../../source/modules/lua.rst:1992
msgid ""
"To output very large response data in a streaming fashion (via the "
"`ngx.flush`_ call, for example), this directive MUST be turned off to "
"minimize memory usage."
msgstr ""

#: ../../source/modules/lua.rst:1994
msgid "This directive is turned ``on`` by default."
msgstr ""

#: ../../source/modules/lua.rst:1996
msgid "This directive was first introduced in the ``v0.5.0rc19`` release."
msgstr ""

#: ../../source/modules/lua.rst:2000
msgid "rewrite_by_lua_no_postpone"
msgstr ""

#: ../../source/modules/lua.rst:2001
msgid "*rewrite_by_lua_no_postpone on|off*"
msgstr ""

#: ../../source/modules/lua.rst:2002
msgid "*rewrite_by_lua_no_postpone off*"
msgstr ""

#: ../../source/modules/lua.rst:2005
msgid ""
"Controls whether or not to disable postponing `rewrite_by_lua`_ and "
"`rewrite_by_lua_file`_ directives to run at the end of the ``rewrite`` "
"request-processing phase. By default, this directive is turned off and the "
"Lua code is postponed to run at the end of the ``rewrite`` phase."
msgstr ""

#: ../../source/modules/lua.rst:2007
msgid "This directive was first introduced in the ``v0.5.0rc29`` release."
msgstr ""

#: ../../source/modules/lua.rst:2011
msgid "lua_transform_underscores_in_response_headers"
msgstr ""

#: ../../source/modules/lua.rst:2012
msgid "*lua_transform_underscores_in_response_headers on|off*"
msgstr ""

#: ../../source/modules/lua.rst:2013
msgid "*lua_transform_underscores_in_response_headers on*"
msgstr ""

#: ../../source/modules/lua.rst:2016
msgid ""
"Controls whether to transform underscores (``_``) in the response header "
"names specified in the `ngx.header.HEADER`_ API to hypens (``-``)."
msgstr ""

#: ../../source/modules/lua.rst:2022
msgid "lua_check_client_abort"
msgstr ""

#: ../../source/modules/lua.rst:2023
msgid "*lua_check_client_abort on|off*"
msgstr ""

#: ../../source/modules/lua.rst:2024
msgid "*lua_check_client_abort off*"
msgstr ""

#: ../../source/modules/lua.rst:2027
msgid ""
"This directive controls whether to check for premature client connection "
"abortion."
msgstr ""

#: ../../source/modules/lua.rst:2029
msgid ""
"When this directive is turned on, the ngx_lua module will monitor the "
"premature connection close event on the downstream connections. And when "
"there is such an event, it will call the user Lua function callback "
"(registered by `ngx.on_abort`_) or just stop and clean up all the Lua "
"\"light threads\" running in the current request's request handler when "
"there is no user callback function registered."
msgstr ""

#: ../../source/modules/lua.rst:2031
msgid ""
"According to the current implementation, however, if the client closes the "
"connection before the Lua code finishes reading the request body data via "
"`ngx.req.socket`_, then ngx_lua will neither stop all the running \"light "
"threads\" nor call the user callback (if `ngx.on_abort`_ has been called). "
"Instead, the reading operation on `ngx.req.socket`_ will just return the "
"error message \"client aborted\" as the second return value (the first "
"return value is surely ``nil``)."
msgstr ""

#: ../../source/modules/lua.rst:2033
msgid ""
"When TCP keepalive is disabled, it is relying on the client side to close "
"the socket gracefully (by sending a ``FIN`` packet or something like that). "
"For (soft) real-time web applications, it is highly recommended to configure"
" the `TCP keepalive <http://tldp.org/HOWTO/TCP-Keepalive-"
"HOWTO/overview.html>`_ support in your system's TCP stack implementation in "
"order to detect \"half-open\" TCP connections in time."
msgstr ""

#: ../../source/modules/lua.rst:2035
msgid ""
"For example, on Linux, you can configure the standard `listen "
"<|HttpCoreModule|#listen>`_ directive in your ``nginx.conf`` file like this:"
msgstr ""

#: ../../source/modules/lua.rst:2042
msgid ""
"On FreeBSD, you can only tune the system-wide configuration for TCP "
"keepalive, for example:"
msgstr ""

#: ../../source/modules/lua.rst:2044
msgid ""
"# sysctl net.inet.tcp.keepintvl=2000 # sysctl net.inet.tcp.keepidle=2000"
msgstr ""

#: ../../source/modules/lua.rst:2047
msgid "This directive was first introduced in the ``v0.7.4`` release."
msgstr ""

#: ../../source/modules/lua.rst:2049
msgid "`ngx.on_abort`_."
msgstr ""

#: ../../source/modules/lua.rst:2053
msgid "lua_max_pending_timers"
msgstr ""

#: ../../source/modules/lua.rst:2054
msgid "*lua_max_pending_timers <count>*"
msgstr ""

#: ../../source/modules/lua.rst:2055
msgid "*lua_max_pending_timers 1024*"
msgstr ""

#: ../../source/modules/lua.rst:2058
msgid "Controls the maximum number of pending timers allowed."
msgstr ""

#: ../../source/modules/lua.rst:2060
msgid "Pending timers are those timers that have not expired yet."
msgstr ""

#: ../../source/modules/lua.rst:2062
msgid ""
"When exceeding this limit, the `ngx.timer.at`_ call will immediately return "
"``nil`` and the error string \"too many pending timers\"."
msgstr ""

#: ../../source/modules/lua.rst:2064 ../../source/modules/lua.rst:2079
msgid "This directive was first introduced in the ``v0.8.0`` release."
msgstr ""

#: ../../source/modules/lua.rst:2068
msgid "lua_max_running_timers"
msgstr ""

#: ../../source/modules/lua.rst:2069
msgid "*lua_max_running_timers <count>*"
msgstr ""

#: ../../source/modules/lua.rst:2070
msgid "*lua_max_running_timers 256*"
msgstr ""

#: ../../source/modules/lua.rst:2073
msgid "Controls the maximum number of \"running timers\" allowed."
msgstr ""

#: ../../source/modules/lua.rst:2075
msgid ""
"Running timers are those timers whose user callback functions are still "
"running."
msgstr ""

#: ../../source/modules/lua.rst:2077
msgid ""
"When exceeding this limit, Nginx will stop running the callbacks of newly "
"expired timers and log an error message \"N lua_max_running_timers are not "
"enough\" where \"N\" is the current value of this directive."
msgstr ""

#: ../../source/modules/lua.rst:2084
msgid "Nginx API for Lua"
msgstr ""

#: ../../source/modules/lua.rst:2086
msgid "<!-- inline-toc -->"
msgstr ""

#: ../../source/modules/lua.rst:2089
msgid "Introduction"
msgstr ""

#: ../../source/modules/lua.rst:2090
msgid ""
"The various ``*_by_lua`` and ``*_by_lua_file`` configuration directives "
"serve as gateways to the Lua API within the ``nginx.conf`` file. The Nginx "
"Lua API described below can only be called within the user Lua code run in "
"the context of these configuration directives."
msgstr ""

#: ../../source/modules/lua.rst:2092
msgid ""
"The API is exposed to Lua in the form of two standard packages ``ngx`` and "
"``ndk``. These packages are in the default global scope within ngx_lua and "
"are always available within ngx_lua directives."
msgstr ""

#: ../../source/modules/lua.rst:2094
msgid "The packages can be introduced into external Lua modules like this:"
msgstr ""

#: ../../source/modules/lua.rst:2109
msgid ""
"Use of the `package.seeall <http://www.lua.org/manual/5.1/manual.html#pdf-"
"package.seeall>`_ flag is strongly discouraged due to its various bad side-"
"effects."
msgstr ""

#: ../../source/modules/lua.rst:2111
msgid ""
"It is also possible to directly require the packages in external Lua "
"modules:"
msgstr ""

#: ../../source/modules/lua.rst:2119
msgid ""
"The ability to require these packages was introduced in the ``v0.2.1rc19`` "
"release."
msgstr ""

#: ../../source/modules/lua.rst:2121
msgid ""
"Network I/O operations in user code should only be done through the Nginx "
"Lua API calls as the Nginx event loop may be blocked and performance drop "
"off dramatically otherwise. Disk operations with relatively small amount of "
"data can be done using the standard Lua ``io`` library but huge file reading"
" and writing should be avoided wherever possible as they may block the Nginx"
" process significantly. Delegating all network and disk I/O operations to "
"Nginx's subrequests (via the `ngx.location.capture`_ method and similar) is "
"strongly recommended for maximum performance."
msgstr ""

#: ../../source/modules/lua.rst:2125
msgid "ngx.arg"
msgstr ""

#: ../../source/modules/lua.rst:2126
msgid "*val = ngx.arg[index]*"
msgstr ""

#: ../../source/modules/lua.rst:2127
msgid "*set_by_lua\\*, body_filter_by_lua\\**"
msgstr ""

#: ../../source/modules/lua.rst:2129
msgid ""
"When this is used in the context of the `set_by_lua`_ or `set_by_lua_file`_ "
"directives, this table is read-only and holds the input arguments to the "
"config directives:"
msgstr ""

#: ../../source/modules/lua.rst:2136
msgid "Here is an example"
msgstr ""

#: ../../source/modules/lua.rst:2152
msgid "that writes out ``88``, the sum of ``32`` and ``56``."
msgstr ""

#: ../../source/modules/lua.rst:2154
msgid ""
"When this table is used in the context of `body_filter_by_lua`_ or "
"`body_filter_by_lua_file`_, the first element holds the input data chunk to "
"the output filter code and the second element holds the boolean flag for the"
" \"eof\" flag indicating the end of the whole output data stream."
msgstr ""

#: ../../source/modules/lua.rst:2156
msgid ""
"The data chunk and \"eof\" flag passed to the downstream Nginx output "
"filters can also be overridden by assigning values directly to the "
"corresponding table elements. When setting ``nil`` or an empty Lua string "
"value to ``ngx.arg[1]``, no data chunk will be passed to the downstream "
"Nginx output filters at all."
msgstr ""

#: ../../source/modules/lua.rst:2160
msgid "ngx.var.VARIABLE"
msgstr ""

#: ../../source/modules/lua.rst:2161
msgid "*ngx.var.VAR_NAME*"
msgstr ""

#: ../../source/modules/lua.rst:2162 ../../source/modules/lua.rst:2910
#: ../../source/modules/lua.rst:4281
msgid ""
"*set_by_lua\\*, rewrite_by_lua\\*, access_by_lua\\*, content_by_lua\\*, "
"header_filter_by_lua\\*, body_filter_by_lua\\*, log_by_lua\\**"
msgstr ""

#: ../../source/modules/lua.rst:2164
msgid "Read and write Nginx variable values."
msgstr ""

#: ../../source/modules/lua.rst:2172
msgid "Note that only already defined nginx variables can be written to."
msgstr ""

#: ../../source/modules/lua.rst:2174
msgid "For example:"
msgstr ""

#: ../../source/modules/lua.rst:2187
msgid "That is, nginx variables cannot be created on-the-fly."
msgstr ""

#: ../../source/modules/lua.rst:2189
msgid ""
"Some special nginx variables like ``$args`` and ``$limit_rate`` can be "
"assigned a value, many others are not, like ``$query_string``, "
"``$arg_PARAMETER``, and ``$http_NAME``."
msgstr ""

#: ../../source/modules/lua.rst:2191
msgid ""
"Nginx regex group capturing variables ``$1``, ``$2``, ``$3``, and etc, can "
"be read by this interface as well, by writing ``ngx.var[1]``, "
"``ngx.var[2]``, ``ngx.var[3]``, and etc."
msgstr ""

#: ../../source/modules/lua.rst:2193
msgid ""
"Setting ``ngx.var.Foo`` to a ``nil`` value will unset the ``$Foo`` Nginx "
"variable."
msgstr ""

#: ../../source/modules/lua.rst:2200
msgid ""
"When reading from an Nginx variable, Nginx will allocate memory in the per-"
"request memory pool which is freed only at request termination. So when you "
"need to read from an Nginx variable repeatedly in your Lua code, cache the "
"Nginx variable value to your own Lua variable, for example,"
msgstr ""

#: ../../source/modules/lua.rst:2208
msgid ""
"to prevent (temporary) memory leaking within the current request's lifetime."
" Another way of caching the result is to use the `ngx.ctx`_ table."
msgstr ""

#: ../../source/modules/lua.rst:2210
msgid ""
"This API requires a relatively expensive metamethod call and it is "
"recommended to avoid using it on hot code paths."
msgstr ""

#: ../../source/modules/lua.rst:2214
msgid "Core constants"
msgstr ""

#: ../../source/modules/lua.rst:2215
msgid ""
"*init_by_lua\\*, set_by_lua\\*, rewrite_by_lua\\*, access_by_lua\\*, "
"content_by_lua\\*, header_filter_by_lua\\*, body_filter_by_lua, "
"*log_by_lua\\*, ngx.timer.\\**"
msgstr ""

#: ../../source/modules/lua.rst:2226
msgid ""
"Note that only three of these constants are utilized by the `Nginx API for "
"Lua`_ (i.e., `ngx.exit`_ accepts ``NGX_OK``, ``NGX_ERROR``, and "
"``NGX_DECLINED`` as input)."
msgstr ""

#: ../../source/modules/lua.rst:2233
msgid ""
"The ``ngx.null`` constant is a ``NULL`` light userdata usually used to "
"represent nil values in Lua tables etc and is similar to the `lua-cjson "
"<http://www.kyne.com.au/~mark/software/lua-cjson.php>`__ library's "
"``cjson.null`` constant. This constant was first introduced in the "
"``v0.5.0rc5`` release."
msgstr ""

#: ../../source/modules/lua.rst:2235
msgid ""
"The ``ngx.DECLINED`` constant was first introduced in the ``v0.5.0rc19`` "
"release."
msgstr ""

#: ../../source/modules/lua.rst:2239
msgid "HTTP method constants"
msgstr ""

#: ../../source/modules/lua.rst:2240 ../../source/modules/lua.rst:2266
msgid ""
"*init_by_lua\\*, set_by_lua\\*, rewrite_by_lua\\*, access_by_lua\\*, "
"content_by_lua\\*, header_filter_by_lua\\*, body_filter_by_lua, "
"log_by_lua\\*, ngx.timer.\\**"
msgstr ""

#: ../../source/modules/lua.rst:2261
msgid ""
"These constants are usually used in `ngx.location.capture`_ and "
"`ngx.location.capture_multi`_ method calls."
msgstr ""

#: ../../source/modules/lua.rst:2265
msgid "HTTP status constants"
msgstr ""

#: ../../source/modules/lua.rst:2290
msgid "Nginx log level constants"
msgstr ""

#: ../../source/modules/lua.rst:2291
msgid ""
"*set_by_lua\\*, rewrite_by_lua\\*, access_by_lua\\*, content_by_lua\\*, "
"header_filter_by_lua\\*, body_filter_by_lua, log_by_lua\\*, ngx.timer.\\**"
msgstr ""

#: ../../source/modules/lua.rst:2306
msgid "These constants are usually used by the `ngx.log`_ method."
msgstr ""

#: ../../source/modules/lua.rst:2310
msgid "print"
msgstr ""

#: ../../source/modules/lua.rst:2311
msgid "*print(...)*"
msgstr ""

#: ../../source/modules/lua.rst:2312
msgid ""
"*init_by_lua\\*, init_worker_by_lua\\*, set_by_lua\\*, rewrite_by_lua\\*, "
"access_by_lua\\*, content_by_lua\\*, header_filter_by_lua\\*, "
"body_filter_by_lua, log_by_lua\\*, ngx.timer.\\**"
msgstr ""

#: ../../source/modules/lua.rst:2314
msgid ""
"Writes argument values into the nginx ``error.log`` file with the "
"``ngx.NOTICE`` log level."
msgstr ""

#: ../../source/modules/lua.rst:2316
msgid "It is equivalent to"
msgstr ""

#: ../../source/modules/lua.rst:2323
msgid ""
"Lua ``nil`` arguments are accepted and result in literal ``\"nil\"`` strings"
" while Lua booleans result in literal ``\"true\"`` or ``\"false\"`` strings."
" And the ``ngx.null`` constant will yield the ``\"null\"`` string output."
msgstr ""

#: ../../source/modules/lua.rst:2325 ../../source/modules/lua.rst:3828
msgid ""
"There is a hard coded ``2048`` byte limitation on error message lengths in "
"the Nginx core. This limit includes trailing newlines and leading time "
"stamps. If the message size exceeds this limit, Nginx will truncate the "
"message text accordingly. This limit can be manually modified by editing the"
" ``NGX_MAX_ERROR_STR`` macro definition in the ``src/core/ngx_log.h`` file "
"in the Nginx source tree."
msgstr ""

#: ../../source/modules/lua.rst:2329
msgid "ngx.ctx"
msgstr ""

#: ../../source/modules/lua.rst:2330
msgid ""
"*init_worker_by_lua\\*, set_by_lua\\*, rewrite_by_lua\\*, access_by_lua\\*, "
"content_by_lua\\*, header_filter_by_lua\\*, body_filter_by_lua, "
"log_by_lua\\*, ngx.timer.\\**"
msgstr ""

#: ../../source/modules/lua.rst:2332
msgid ""
"This table can be used to store per-request Lua context data and has a life "
"time identical to the current request (as with the Nginx variables)."
msgstr ""

#: ../../source/modules/lua.rst:2334
msgid "Consider the following example,"
msgstr ""

#: ../../source/modules/lua.rst:2351
msgid "Then ``GET /test`` will yield the output"
msgstr ""

#: ../../source/modules/lua.rst:2358
msgid ""
"That is, the ``ngx.ctx.foo`` entry persists across the rewrite, access, and "
"content phases of a request."
msgstr ""

#: ../../source/modules/lua.rst:2360
msgid ""
"Every request, including subrequests, has its own copy of the table. For "
"example:"
msgstr ""

#: ../../source/modules/lua.rst:2383
msgid "Then ``GET /main`` will give the output"
msgstr ""

#: ../../source/modules/lua.rst:2393
msgid ""
"Here, modification of the ``ngx.ctx.blah`` entry in the subrequest does not "
"affect the one in the parent request. This is because they have two separate"
" versions of ``ngx.ctx.blah``."
msgstr ""

#: ../../source/modules/lua.rst:2395
msgid ""
"Internal redirection will destroy the original request ``ngx.ctx`` data (if "
"any) and the new request will have an empty ``ngx.ctx`` table. For instance,"
msgstr ""

#: ../../source/modules/lua.rst:2413
msgid "Then ``GET /orig`` will give"
msgstr ""

#: ../../source/modules/lua.rst:2420
msgid "rather than the original ``\"hello\"`` value."
msgstr ""

#: ../../source/modules/lua.rst:2422
msgid ""
"Arbitrary data values, including Lua closures and nested tables, can be "
"inserted into this \"magic\" table. It also allows the registration of "
"custom meta methods."
msgstr ""

#: ../../source/modules/lua.rst:2424
msgid ""
"Overriding ``ngx.ctx`` with a new Lua table is also supported, for example,"
msgstr ""

#: ../../source/modules/lua.rst:2431
msgid ""
"When being used in the context of `init_worker_by_lua`_, this table just has"
" the same lifetime of the current Lua handler."
msgstr ""

#: ../../source/modules/lua.rst:2433
msgid ""
"The ``ngx.ctx`` lookup requires relatively expensive metamethod calls and it"
" is much slower than explicitly passing per-request data along by your own "
"function arguments. So do not abuse this API for saving your own function "
"arguments because it usually has quite some performance impact. And because "
"of the metamethod magic, never \"local\" the ``ngx.ctx`` table outside your "
"function scope."
msgstr ""

#: ../../source/modules/lua.rst:2437
msgid "ngx.location.capture"
msgstr ""

#: ../../source/modules/lua.rst:2438
msgid "*res = ngx.location.capture(uri, options?)*"
msgstr ""

#: ../../source/modules/lua.rst:2439 ../../source/modules/lua.rst:2707
#: ../../source/modules/lua.rst:3421 ../../source/modules/lua.rst:3449
#: ../../source/modules/lua.rst:3465 ../../source/modules/lua.rst:3491
#: ../../source/modules/lua.rst:3511 ../../source/modules/lua.rst:3525
#: ../../source/modules/lua.rst:3604 ../../source/modules/lua.rst:3626
#: ../../source/modules/lua.rst:3685 ../../source/modules/lua.rst:3753
#: ../../source/modules/lua.rst:3775 ../../source/modules/lua.rst:3812
#: ../../source/modules/lua.rst:3835 ../../source/modules/lua.rst:3901
#: ../../source/modules/lua.rst:5748
msgid "*rewrite_by_lua\\*, access_by_lua\\*, content_by_lua\\**"
msgstr ""

#: ../../source/modules/lua.rst:2441
msgid ""
"Issue a synchronous but still non-blocking *Nginx Subrequest* using ``uri``."
msgstr ""

#: ../../source/modules/lua.rst:2443
msgid ""
"Nginx's subrequests provide a powerful way to make non-blocking internal "
"requests to other locations configured with disk file directory or *any* "
"other nginx C modules like ``ngx_proxy``, ``ngx_fastcgi``, ``ngx_memc``, "
"``ngx_postgres``, ``ngx_drizzle``, and even ngx_lua itself and etc etc etc."
msgstr ""

#: ../../source/modules/lua.rst:2445
msgid ""
"Also note that subrequests just mimic the HTTP interface but there is *no* "
"extra HTTP/TCP traffic *nor* IPC involved. Everything works internally, "
"efficiently, on the C level."
msgstr ""

#: ../../source/modules/lua.rst:2447
msgid ""
"Subrequests are completely different from HTTP 301/302 redirection (via "
"`ngx.redirect`_) and internal redirection (via `ngx.exec`_)."
msgstr ""

#: ../../source/modules/lua.rst:2449
msgid ""
"You should always read the request body (by either calling "
"`ngx.req.read_body`_ or configuring `lua_need_request_body`_ on) before "
"initiating a subrequest."
msgstr ""

#: ../../source/modules/lua.rst:2451
msgid "Here is a basic example:"
msgstr ""

#: ../../source/modules/lua.rst:2458
msgid ""
"Returns a Lua table with three slots (``res.status``, ``res.header``, "
"``res.body``, and ``res.truncated``)."
msgstr ""

#: ../../source/modules/lua.rst:2460
msgid ""
"``res.status`` holds the response status code for the subrequest response."
msgstr ""

#: ../../source/modules/lua.rst:2462
msgid ""
"``res.header`` holds all the response headers of the subrequest and it is a "
"normal Lua table. For multi-value response headers, the value is a Lua "
"(array) table that holds all the values in the order that they appear. For "
"instance, if the subrequest response headers contain the following lines:"
msgstr ""

#: ../../source/modules/lua.rst:2471
msgid ""
"Then ``res.header[\"Set-Cookie\"]`` will be evaluated to the table value "
"``{\"a=3\", \"foo=bar\", \"baz=blah\"}``."
msgstr ""

#: ../../source/modules/lua.rst:2474
msgid ""
"``res.body`` holds the subrequest's response body data, which might be "
"truncated. You always need to check the ``res.truncated`` boolean flag to "
"see if ``res.body`` contains truncated data. The data truncation here can "
"only be caused by those unrecoverable errors in your subrequests like the "
"cases that the remote end aborts the connection prematurely in the middle of"
" the response body data stream or a read timeout happens when your "
"subrequest is receiving the response body data from the remote."
msgstr ""

#: ../../source/modules/lua.rst:2476
msgid "URI query strings can be concatenated to URI itself, for instance,"
msgstr ""

#: ../../source/modules/lua.rst:2483
msgid ""
"Named locations like ``@foo`` are not allowed due to a limitation in the "
"nginx core. Use normal locations combined with the ``internal`` directive to"
" prepare internal-only locations."
msgstr ""

#: ../../source/modules/lua.rst:2485
msgid ""
"An optional option table can be fed as the second argument, which supports "
"the options:"
msgstr ""

#: ../../source/modules/lua.rst:2487
msgid ""
"specify the subrequest's request method, which only accepts constants like "
"``ngx.HTTP_POST``."
msgstr ""

#: ../../source/modules/lua.rst:2488
msgid "specify the subrequest's request body (string value only)."
msgstr ""

#: ../../source/modules/lua.rst:2489
msgid ""
"specify the subrequest's URI query arguments (both string value and Lua "
"tables are accepted)"
msgstr ""

#: ../../source/modules/lua.rst:2490
msgid ""
"specify a Lua table to be the `ngx.ctx`_ table for the subrequest. It can be"
" the current request's `ngx.ctx`_ table, which effectively makes the parent "
"and its subrequest to share exactly the same context table. This option was "
"first introduced in the ``v0.3.1rc25`` release."
msgstr ""

#: ../../source/modules/lua.rst:2491
msgid ""
"take a Lua table which holds the values to set the specified Nginx variables"
" in the subrequest as this option's value. This option was first introduced "
"in the ``v0.3.1rc31`` release."
msgstr ""

#: ../../source/modules/lua.rst:2492
msgid ""
"specify whether to copy over all the Nginx variable values of the current "
"request to the subrequest in question. modifications of the nginx variables "
"in the subrequest will not affect the current (parent) request. This option "
"was first introduced in the ``v0.3.1rc31`` release."
msgstr ""

#: ../../source/modules/lua.rst:2493
msgid ""
"specify whether to share all the Nginx variables of the subrequest with the "
"current (parent) request. modifications of the Nginx variables in the "
"subrequest will affect the current (parent) request. Enabling this option "
"may lead to hard-to-debug issues due to bad side-effects and is considered "
"bad and harmful. Only enable this option when you completely know what you "
"are doing."
msgstr ""

#: ../../source/modules/lua.rst:2494
msgid ""
"when set to true, the current (parent) request's request body will always be"
" forwarded to the subrequest being created if the ``body`` option is not "
"specified. The request body read by either `ngx.req.read_body() "
"<ngx.req.read_body_>`__ or `lua_need_request_body on "
"<lua_need_request_body_>`__ will be directly forwarded to the subrequest "
"without copying the whole request body data when creating the subrequest (no"
" matter the request body data is buffered in memory buffers or temporary "
"files). By default, this option is ``false`` and when the ``body`` option is"
" not specified, the request body of the current (parent) request is only "
"forwarded when the subrequest takes the ``PUT`` or ``POST`` request method."
msgstr ""

#: ../../source/modules/lua.rst:2496
msgid "Issuing a POST subrequest, for example, can be done as follows"
msgstr ""

#: ../../source/modules/lua.rst:2506
msgid "See HTTP method constants methods other than POST."
msgstr ""

#: ../../source/modules/lua.rst:2508
msgid "The ``method`` option is ``ngx.HTTP_GET`` by default."
msgstr ""

#: ../../source/modules/lua.rst:2510
msgid "The ``args`` option can specify extra URI arguments, for instance,"
msgstr ""

#: ../../source/modules/lua.rst:2519 ../../source/modules/lua.rst:2826
#: ../../source/modules/lua.rst:3403 ../../source/modules/lua.rst:3733
msgid "is equivalent to"
msgstr ""

#: ../../source/modules/lua.rst:2526
msgid ""
"that is, this method will escape argument keys and values according to URI "
"rules and concatenate them together into a complete query string. The format"
" for the Lua table passed as the ``args`` argument is identical to the "
"format used in the `ngx.encode_args`_ method."
msgstr ""

#: ../../source/modules/lua.rst:2528
msgid "The ``args`` option can also take plain query strings:"
msgstr ""

#: ../../source/modules/lua.rst:2537
msgid "This is functionally identical to the previous examples."
msgstr ""

#: ../../source/modules/lua.rst:2539
msgid ""
"The ``share_all_vars`` option controls whether to share nginx variables "
"among the current request and its subrequests."
msgstr ""

#: ../../source/modules/lua.rst:2541
msgid ""
"If this option is set to ``true``, then the current request and associated "
"subrequests will share the same Nginx variable scope. Hence, changes to "
"Nginx variables made by a subrequest will affect the current request."
msgstr ""

#: ../../source/modules/lua.rst:2543
msgid ""
"Care should be taken in using this option as variable scope sharing can have"
" unexpected side effects. The ``args``, ``vars``, or ``copy_all_vars`` "
"options are generally preferable instead."
msgstr ""

#: ../../source/modules/lua.rst:2545
msgid "This option is set to ``false`` by default"
msgstr ""

#: ../../source/modules/lua.rst:2566
msgid "Accessing location ``/lua`` gives"
msgstr ""

#: ../../source/modules/lua.rst:2574
msgid ""
"The ``copy_all_vars`` option provides a copy of the parent request's Nginx "
"variables to subrequests when such subrequests are issued. Changes made to "
"these variables by such subrequests will not affect the parent request or "
"any other subrequests sharing the parent request's variables."
msgstr ""

#: ../../source/modules/lua.rst:2595
msgid "Request ``GET /lua`` will give the output"
msgstr ""

#: ../../source/modules/lua.rst:2603
msgid ""
"Note that if both ``share_all_vars`` and ``copy_all_vars`` are set to true, "
"then ``share_all_vars`` takes precedence."
msgstr ""

#: ../../source/modules/lua.rst:2605
msgid ""
"In addition to the two settings above, it is possible to specify values for "
"variables in the subrequest using the ``vars`` option. These variables are "
"set after the sharing or copying of variables has been evaluated, and "
"provides a more efficient method of passing specific values to a subrequest "
"over encoding them as URL arguments and unescaping them in the Nginx config "
"file."
msgstr ""

#: ../../source/modules/lua.rst:2628
msgid "Accessing ``/lua`` will yield the output"
msgstr ""

#: ../../source/modules/lua.rst:2636
msgid ""
"The ``ctx`` option can be used to specify a custom Lua table to serve as the"
" `ngx.ctx`_ table for the subrequest."
msgstr ""

#: ../../source/modules/lua.rst:2656
msgid "Then request ``GET /lua`` gives"
msgstr ""

#: ../../source/modules/lua.rst:2664
msgid ""
"It is also possible to use this ``ctx`` option to share the same `ngx.ctx`_ "
"table between the current (parent) request and the subrequest:"
msgstr ""

#: ../../source/modules/lua.rst:2681
msgid "Request ``GET /lua`` yields the output"
msgstr ""

#: ../../source/modules/lua.rst:2688
msgid ""
"Note that subrequests issued by `ngx.location.capture`_ inherit all the "
"request headers of the current request by default and that this may have "
"unexpected side effects on the subrequest responses. For example, when using"
" the standard ``ngx_proxy`` module to serve subrequests, an \"Accept-"
"Encoding: gzip\" header in the main request may result in gzipped responses "
"that cannot be handled properly in Lua code. Original request headers should"
" be ignored by setting `proxy_pass_request_headers "
"<|HttpProxyModule|#proxy_pass_request_headers>`_ to ``off`` in subrequest "
"locations."
msgstr ""

#: ../../source/modules/lua.rst:2690
msgid ""
"When the ``body`` option is not specified and the ``always_forward_body`` "
"option is false (the default value), the ``POST`` and ``PUT`` subrequests "
"will inherit the request bodies of the parent request (if any)."
msgstr ""

#: ../../source/modules/lua.rst:2692
msgid ""
"There is a hard-coded upper limit on the number of concurrent subrequests "
"possible for every main request. In older versions of Nginx, the limit was "
"``50`` concurrent subrequests and in more recent versions, Nginx ``1.1.x`` "
"onwards, this was increased to ``200`` concurrent subrequests. When this "
"limit is exceeded, the following error message is added to the ``error.log``"
" file:"
msgstr ""

#: ../../source/modules/lua.rst:2699
msgid ""
"The limit can be manually modified if required by editing the definition of "
"the ``NGX_HTTP_MAX_SUBREQUESTS`` macro in the "
"``nginx/src/http/ngx_http_request.h`` file in the Nginx source tree."
msgstr ""

#: ../../source/modules/lua.rst:2701 ../../source/modules/lua.rst:2765
msgid ""
"Please also refer to restrictions on capturing locations configured by "
"`subrequest directives of other modules <Locations Configured by Subrequest "
"Directives of Other Modules_>`__."
msgstr ""

#: ../../source/modules/lua.rst:2705
msgid "ngx.location.capture_multi"
msgstr ""

#: ../../source/modules/lua.rst:2706
msgid ""
"*res1, res2, ... = ngx.location.capture_multi({ {uri, options?}, {uri, "
"options?}, ... })*"
msgstr ""

#: ../../source/modules/lua.rst:2709
msgid ""
"Just like `ngx.location.capture`_, but supports multiple subrequests running"
" in parallel."
msgstr ""

#: ../../source/modules/lua.rst:2711
msgid ""
"This function issues several parallel subrequests specified by the input "
"table and returns their results in the same order. For example,"
msgstr ""

#: ../../source/modules/lua.rst:2730
msgid "This function will not return until all the subrequests terminate."
msgstr ""

#: ../../source/modules/lua.rst:2732
msgid ""
"The total latency is the longest latency of the individual subrequests "
"rather than the sum."
msgstr ""

#: ../../source/modules/lua.rst:2734
msgid ""
"Lua tables can be used for both requests and responses when the number of "
"subrequests to be issued is not known in advance:"
msgstr ""

#: ../../source/modules/lua.rst:2754
msgid ""
"The `ngx.location.capture`_ function is just a special form of this "
"function. Logically speaking, the `ngx.location.capture`_ can be implemented"
" like this"
msgstr ""

#: ../../source/modules/lua.rst:2769
msgid "ngx.status"
msgstr ""

#: ../../source/modules/lua.rst:2770 ../../source/modules/lua.rst:2891
#: ../../source/modules/lua.rst:3128 ../../source/modules/lua.rst:3304
msgid ""
"*set_by_lua\\*, rewrite_by_lua\\*, access_by_lua\\*, content_by_lua\\*, "
"header_filter_by_lua\\*, body_filter_by_lua, log_by_lua\\**"
msgstr ""

#: ../../source/modules/lua.rst:2772
msgid ""
"Read and write the current request's response status. This should be called "
"before sending out the response headers."
msgstr ""

#: ../../source/modules/lua.rst:2779
msgid ""
"Setting ``ngx.status`` after the response header is sent out has no effect "
"but leaving an error message in your nginx's error log file:"
msgstr ""

#: ../../source/modules/lua.rst:2787
msgid "ngx.header.HEADER"
msgstr ""

#: ../../source/modules/lua.rst:2788
msgid "*ngx.header.HEADER = VALUE*"
msgstr ""

#: ../../source/modules/lua.rst:2789
msgid "*value = ngx.header.HEADER*"
msgstr ""

#: ../../source/modules/lua.rst:2790 ../../source/modules/lua.rst:3213
msgid ""
"*rewrite_by_lua\\*, access_by_lua\\*, content_by_lua\\*, "
"header_filter_by_lua\\*, body_filter_by_lua, log_by_lua\\**"
msgstr ""

#: ../../source/modules/lua.rst:2792
msgid ""
"Set, add to, or clear the current request's ``HEADER`` response header that "
"is to be sent."
msgstr ""

#: ../../source/modules/lua.rst:2794
msgid ""
"Underscores (``_``) in the header names will be replaced by hyphens (``-``) "
"by default. This transformation can be turned off via the "
"`lua_transform_underscores_in_response_headers`_ directive."
msgstr ""

#: ../../source/modules/lua.rst:2796
msgid "The header names are matched case-insensitively."
msgstr ""

#: ../../source/modules/lua.rst:2805
msgid "Multi-value headers can be set this way:"
msgstr ""

#: ../../source/modules/lua.rst:2811
msgid "will yield"
msgstr ""

#: ../../source/modules/lua.rst:2818
msgid "in the response headers."
msgstr ""

#: ../../source/modules/lua.rst:2820
msgid ""
"Only Lua tables are accepted (Only the last element in the table will take "
"effect for standard headers such as ``Content-Type`` that only accept a "
"single value)."
msgstr ""

#: ../../source/modules/lua.rst:2832
msgid ""
"Setting a slot to ``nil`` effectively removes it from the response headers:"
msgstr ""

#: ../../source/modules/lua.rst:2838
msgid "The same applies to assigning an empty table:"
msgstr ""

#: ../../source/modules/lua.rst:2844
msgid ""
"Setting ``ngx.header.HEADER`` after sending out response headers (either "
"explicitly with `ngx.send_headers`_ or implicitly with `ngx.print`_ and "
"similar) will throw out a Lua exception."
msgstr ""

#: ../../source/modules/lua.rst:2846
msgid ""
"Reading ``ngx.header.HEADER`` will return the value of the response header "
"named ``HEADER``."
msgstr ""

#: ../../source/modules/lua.rst:2848
msgid ""
"Underscores (``_``) in the header names will also be replaced by dashes "
"(``-``) and the header names will be matched case-insensitively. If the "
"response header is not present at all, ``nil`` will be returned."
msgstr ""

#: ../../source/modules/lua.rst:2850
msgid ""
"This is particularly useful in the context of `header_filter_by_lua`_ and "
"`header_filter_by_lua_file`_, for example,"
msgstr ""

#: ../../source/modules/lua.rst:2868
msgid ""
"For multi-value headers, all of the values of header will be collected in "
"order and returned as a Lua table. For example, response headers"
msgstr ""

#: ../../source/modules/lua.rst:2875
msgid "will result in"
msgstr ""

#: ../../source/modules/lua.rst:2881
msgid "to be returned when reading ``ngx.header.Foo``."
msgstr ""

#: ../../source/modules/lua.rst:2883
msgid ""
"Note that ``ngx.header`` is not a normal Lua table and as such, it is not "
"possible to iterate through it using the Lua ``ipairs`` function."
msgstr ""

#: ../../source/modules/lua.rst:2885
msgid ""
"For reading *request* headers, use the `ngx.req.get_headers`_ function "
"instead."
msgstr ""

#: ../../source/modules/lua.rst:2889
msgid "ngx.resp.get_headers"
msgstr ""

#: ../../source/modules/lua.rst:2890
msgid "*headers = ngx.resp.get_headers(max_headers?, raw?)*"
msgstr ""

#: ../../source/modules/lua.rst:2893
msgid ""
"Returns a Lua table holding all the current response headers for the current"
" request."
msgstr ""

#: ../../source/modules/lua.rst:2902
msgid ""
"This function has the same signature as `ngx.req.get_headers`_ except "
"getting response headers instead of request headers."
msgstr ""

#: ../../source/modules/lua.rst:2904
msgid "This API was first introduced in the ``v0.9.5`` release."
msgstr ""

#: ../../source/modules/lua.rst:2908
msgid "ngx.req.start_time"
msgstr ""

#: ../../source/modules/lua.rst:2909
msgid "*secs = ngx.req.start_time()*"
msgstr ""

#: ../../source/modules/lua.rst:2912
msgid ""
"Returns a floating-point number representing the timestamp (including "
"milliseconds as the decimal part) when the current request was created."
msgstr ""

#: ../../source/modules/lua.rst:2914
msgid ""
"The following example emulates the ``$request_time`` variable value "
"(provided by |HttpLogModule|) in pure Lua:"
msgstr ""

#: ../../source/modules/lua.rst:2920
msgid "This function was first introduced in the ``v0.7.7`` release."
msgstr ""

#: ../../source/modules/lua.rst:2922
msgid "`ngx.now`_ and `ngx.update_time`_."
msgstr ""

#: ../../source/modules/lua.rst:2926
msgid "ngx.req.http_version"
msgstr ""

#: ../../source/modules/lua.rst:2927
msgid "*num = ngx.req.http_version()*"
msgstr ""

#: ../../source/modules/lua.rst:2928 ../../source/modules/lua.rst:2940
#: ../../source/modules/lua.rst:2980 ../../source/modules/lua.rst:2994
msgid ""
"*set_by_lua\\*, rewrite_by_lua\\*, access_by_lua\\*, content_by_lua\\*, "
"header_filter_by_lua\\**"
msgstr ""

#: ../../source/modules/lua.rst:2930
msgid ""
"Returns the HTTP version number for the current request as a Lua number."
msgstr ""

#: ../../source/modules/lua.rst:2932
msgid ""
"Current possible values are 1.0, 1.1, and 0.9. Returns ``nil`` for "
"unrecognized values."
msgstr ""

#: ../../source/modules/lua.rst:2934 ../../source/modules/lua.rst:2974
msgid "This method was first introduced in the ``v0.7.17`` release."
msgstr ""

#: ../../source/modules/lua.rst:2938
msgid "ngx.req.raw_header"
msgstr ""

#: ../../source/modules/lua.rst:2939
msgid "*str = ngx.req.raw_header(no_request_line?)*"
msgstr ""

#: ../../source/modules/lua.rst:2942
msgid ""
"Returns the original raw HTTP protocol header received by the Nginx server."
msgstr ""

#: ../../source/modules/lua.rst:2944
msgid ""
"By default, the request line and trailing ``CR LF`` terminator will also be "
"included. For example,"
msgstr ""

#: ../../source/modules/lua.rst:2950
msgid "gives something like this:"
msgstr ""

#: ../../source/modules/lua.rst:2959
msgid ""
"You can specify the optional ``no_request_line`` argument as a ``true`` "
"value to exclude the request line from the result. For example,"
msgstr ""

#: ../../source/modules/lua.rst:2966
msgid "outputs something like this:"
msgstr ""

#: ../../source/modules/lua.rst:2978
msgid "ngx.req.get_method"
msgstr ""

#: ../../source/modules/lua.rst:2979
msgid "*method_name = ngx.req.get_method()*"
msgstr ""

#: ../../source/modules/lua.rst:2982
msgid ""
"Retrieves the current request's request method name. Strings like "
"``\"GET\"`` and ``\"POST\"`` are returned instead of numerical `method "
"constants <HTTP method constants_>`_."
msgstr ""

#: ../../source/modules/lua.rst:2984
msgid ""
"If the current request is an Nginx subrequest, then the subrequest's method "
"name will be returned."
msgstr ""

#: ../../source/modules/lua.rst:2986 ../../source/modules/lua.rst:3000
msgid "This method was first introduced in the ``v0.5.6`` release."
msgstr ""

#: ../../source/modules/lua.rst:2988
msgid "`ngx.req.set_method`_."
msgstr ""

#: ../../source/modules/lua.rst:2992
msgid "ngx.req.set_method"
msgstr ""

#: ../../source/modules/lua.rst:2993
msgid "*ngx.req.set_method(method_id)*"
msgstr ""

#: ../../source/modules/lua.rst:2996
msgid ""
"Overrides the current request's request method with the ``request_id`` "
"argument. Currently only numerical `method constants <HTTP method "
"constants_>`_ are supported, like ``ngx.HTTP_POST`` and ``ngx.HTTP_GET``."
msgstr ""

#: ../../source/modules/lua.rst:2998
msgid ""
"If the current request is an Nginx subrequest, then the subrequest's method "
"will be overridden."
msgstr ""

#: ../../source/modules/lua.rst:3002
msgid "`ngx.req.get_method`_."
msgstr ""

#: ../../source/modules/lua.rst:3006
msgid "ngx.req.set_uri"
msgstr ""

#: ../../source/modules/lua.rst:3007
msgid "*ngx.req.set_uri(uri, jump?)*"
msgstr ""

#: ../../source/modules/lua.rst:3008 ../../source/modules/lua.rst:3095
#: ../../source/modules/lua.rst:3369 ../../source/modules/lua.rst:3413
msgid ""
"*set_by_lua\\*, rewrite_by_lua\\*, access_by_lua\\*, content_by_lua\\*, "
"header_filter_by_lua\\*, body_filter_by_lua\\**"
msgstr ""

#: ../../source/modules/lua.rst:3010
msgid ""
"Rewrite the current request's (parsed) URI by the ``uri`` argument. The "
"``uri`` argument must be a Lua string and cannot be of zero length, or a Lua"
" exception will be thrown."
msgstr ""

#: ../../source/modules/lua.rst:3012
msgid ""
"The optional boolean ``jump`` argument can trigger location rematch (or "
"location jump) as |HttpRewriteModule|'s `rewrite "
"<|HttpRewriteModule|#rewrite>`_ directive, that is, when ``jump`` is "
"``true`` (default to ``false``), this function will never return and it will"
" tell Nginx to try re-searching locations with the new URI value at the "
"later ``post-rewrite`` phase and jumping to the new location."
msgstr ""

#: ../../source/modules/lua.rst:3014
msgid ""
"Location jump will not be triggered otherwise, and only the current "
"request's URI will be modified, which is also the default behavior. This "
"function will return but with no returned values when the ``jump`` argument "
"is ``false`` or absent altogether."
msgstr ""

#: ../../source/modules/lua.rst:3016
msgid "For example, the following nginx config snippet"
msgstr ""

#: ../../source/modules/lua.rst:3022
msgid "can be coded in Lua like this:"
msgstr ""

#: ../../source/modules/lua.rst:3028
msgid "Similarly, Nginx config"
msgstr ""

#: ../../source/modules/lua.rst:3034
msgid "can be coded in Lua as"
msgstr ""

#: ../../source/modules/lua.rst:3040
msgid "or equivalently,"
msgstr ""

#: ../../source/modules/lua.rst:3046
msgid ""
"The ``jump`` can only be set to ``true`` in `rewrite_by_lua`_ and "
"`rewrite_by_lua_file`_. Use of jump in other contexts is prohibited and will"
" throw out a Lua exception."
msgstr ""

#: ../../source/modules/lua.rst:3048
msgid ""
"A more sophisticated example involving regex substitutions is as follows"
msgstr ""

#: ../../source/modules/lua.rst:3060
msgid "which is functionally equivalent to"
msgstr ""

#: ../../source/modules/lua.rst:3069
msgid ""
"Note that it is not possible to use this interface to rewrite URI arguments "
"and that `ngx.req.set_uri_args`_ should be used for this instead. For "
"instance, Nginx config"
msgstr ""

#: ../../source/modules/lua.rst:3075
msgid "can be coded as"
msgstr ""

#: ../../source/modules/lua.rst:3082
msgid "or"
msgstr ""

#: ../../source/modules/lua.rst:3089
msgid "This interface was first introduced in the ``v0.3.1rc14`` release."
msgstr ""

#: ../../source/modules/lua.rst:3093
msgid "ngx.req.set_uri_args"
msgstr ""

#: ../../source/modules/lua.rst:3094
msgid "*ngx.req.set_uri_args(args)*"
msgstr ""

#: ../../source/modules/lua.rst:3097
msgid ""
"Rewrite the current request's URI query arguments by the ``args`` argument. "
"The ``args`` argument can be either a Lua string, as in"
msgstr ""

#: ../../source/modules/lua.rst:3104
msgid "or a Lua table holding the query arguments' key-value pairs, as in"
msgstr ""

#: ../../source/modules/lua.rst:3110
msgid ""
"where in the latter case, this method will escape argument keys and values "
"according to the URI escaping rule."
msgstr ""

#: ../../source/modules/lua.rst:3112
msgid "Multi-value arguments are also supported:"
msgstr ""

#: ../../source/modules/lua.rst:3118
msgid "which will result in a query string like ``a=3&b=5&b=6``."
msgstr ""

#: ../../source/modules/lua.rst:3120
msgid "This interface was first introduced in the ``v0.3.1rc13`` release."
msgstr ""

#: ../../source/modules/lua.rst:3122
msgid "`ngx.req.set_uri`_."
msgstr ""

#: ../../source/modules/lua.rst:3126
msgid "ngx.req.get_uri_args"
msgstr ""

#: ../../source/modules/lua.rst:3127
msgid "*args = ngx.req.get_uri_args(max_args?)*"
msgstr ""

#: ../../source/modules/lua.rst:3130
msgid ""
"Returns a Lua table holding all the current request URL query arguments."
msgstr ""

#: ../../source/modules/lua.rst:3147
msgid ""
"Then ``GET /test?foo=bar&bar=baz&bar=blah`` will yield the response body"
msgstr ""

#: ../../source/modules/lua.rst:3154
msgid ""
"Multiple occurrences of an argument key will result in a table value holding"
" all the values for that key in order."
msgstr ""

#: ../../source/modules/lua.rst:3156
msgid ""
"Keys and values are unescaped according to URI escaping rules. In the "
"settings above, ``GET /test?a%20b=1%61+2`` will yield:"
msgstr ""

#: ../../source/modules/lua.rst:3162 ../../source/modules/lua.rst:3268
msgid ""
"Arguments without the ``=<value>`` parts are treated as boolean arguments. "
"``GET /test?foo&bar`` will yield:"
msgstr ""

#: ../../source/modules/lua.rst:3169
msgid ""
"That is, they will take Lua boolean values ``true``. However, they are "
"different from arguments taking empty string values. ``GET /test?foo=&bar=``"
" will give something like"
msgstr ""

#: ../../source/modules/lua.rst:3176
msgid ""
"Empty key arguments are discarded. ``GET /test?=hello&=world`` will yield an"
" empty output for instance."
msgstr ""

#: ../../source/modules/lua.rst:3178
msgid ""
"Updating query arguments via the nginx variable ``$args`` (or "
"``ngx.var.args`` in Lua) at runtime is also supported:"
msgstr ""

#: ../../source/modules/lua.rst:3185
msgid "Here the ``args`` table will always look like"
msgstr ""

#: ../../source/modules/lua.rst:3191
msgid "regardless of the actual request query string."
msgstr ""

#: ../../source/modules/lua.rst:3193 ../../source/modules/lua.rst:3284
msgid ""
"Note that a maximum of 100 request arguments are parsed by default "
"(including those with the same name) and that additional request arguments "
"are silently discarded to guard against potential denial of service attacks."
msgstr ""

#: ../../source/modules/lua.rst:3195 ../../source/modules/lua.rst:3286
msgid ""
"However, the optional ``max_args`` function argument can be used to override"
" this limit:"
msgstr ""

#: ../../source/modules/lua.rst:3201 ../../source/modules/lua.rst:3292
#: ../../source/modules/lua.rst:4033
msgid ""
"This argument can be set to zero to remove the limit and to process all "
"request arguments received:"
msgstr ""

#: ../../source/modules/lua.rst:3207 ../../source/modules/lua.rst:3298
#: ../../source/modules/lua.rst:4039
msgid "Removing the ``max_args`` cap is strongly discouraged."
msgstr ""

#: ../../source/modules/lua.rst:3211
msgid "ngx.req.get_post_args"
msgstr ""

#: ../../source/modules/lua.rst:3212
msgid "*args, err = ngx.req.get_post_args(max_args?)*"
msgstr ""

#: ../../source/modules/lua.rst:3215
msgid ""
"Returns a Lua table holding all the current request POST query arguments (of"
" the MIME type ``application/x-www-form-urlencoded``). Call "
"`ngx.req.read_body`_ to read the request body first or turn on the "
"`lua_need_request_body`_ directive to avoid errors."
msgstr ""

#: ../../source/modules/lua.rst:3237
msgid "Then"
msgstr ""

#: ../../source/modules/lua.rst:3244
msgid "will yield the response body like"
msgstr ""

#: ../../source/modules/lua.rst:3251
msgid ""
"Multiple occurrences of an argument key will result in a table value holding"
" all of the values for that key in order."
msgstr ""

#: ../../source/modules/lua.rst:3253
msgid "Keys and values will be unescaped according to URI escaping rules."
msgstr ""

#: ../../source/modules/lua.rst:3255
msgid "With the settings above,"
msgstr ""

#: ../../source/modules/lua.rst:3262
msgid "will yield:"
msgstr ""

#: ../../source/modules/lua.rst:3275
msgid ""
"That is, they will take Lua boolean values ``true``. However, they are "
"different from arguments taking empty string values. ``POST /test`` with "
"request body ``foo=&bar=`` will return something like"
msgstr ""

#: ../../source/modules/lua.rst:3282
msgid ""
"Empty key arguments are discarded. ``POST /test`` with body "
"``=hello&=world`` will yield empty outputs for instance."
msgstr ""

#: ../../source/modules/lua.rst:3302
msgid "ngx.req.get_headers"
msgstr ""

#: ../../source/modules/lua.rst:3303
msgid "*headers = ngx.req.get_headers(max_headers?, raw?)*"
msgstr ""

#: ../../source/modules/lua.rst:3306
msgid "Returns a Lua table holding all the current request headers."
msgstr ""

#: ../../source/modules/lua.rst:3315
msgid "To read an individual header:"
msgstr ""

#: ../../source/modules/lua.rst:3321
msgid ""
"Note that the `ngx.var.HEADER <ngx.var.VARIABLE_>`_ API call, which uses "
"core `$http_HEADER <|HttpCoreModule|#$http_HEADER>`_ variables, may be more "
"preferable for reading individual request headers."
msgstr ""

#: ../../source/modules/lua.rst:3323
msgid "For multiple instances of request headers such as:"
msgstr ""

#: ../../source/modules/lua.rst:3331
msgid ""
"the value of ``ngx.req.get_headers()[\"Foo\"]`` will be a Lua (array) table "
"such as:"
msgstr ""

#: ../../source/modules/lua.rst:3337
msgid ""
"Note that a maximum of 100 request headers are parsed by default (including "
"those with the same name) and that additional request headers are silently "
"discarded to guard against potential denial of service attacks."
msgstr ""

#: ../../source/modules/lua.rst:3339
msgid ""
"However, the optional ``max_headers`` function argument can be used to "
"override this limit:"
msgstr ""

#: ../../source/modules/lua.rst:3345
msgid ""
"This argument can be set to zero to remove the limit and to process all "
"request headers received:"
msgstr ""

#: ../../source/modules/lua.rst:3351
msgid "Removing the ``max_headers`` cap is strongly discouraged."
msgstr ""

#: ../../source/modules/lua.rst:3353
msgid ""
"Since the ``0.6.9`` release, all the header names in the Lua table returned "
"are converted to the pure lower-case form by default, unless the ``raw`` "
"argument is set to ``true`` (default to ``false``)."
msgstr ""

#: ../../source/modules/lua.rst:3355
msgid ""
"Also, by default, an ``__index`` metamethod is added to the resulting Lua "
"table and will normalize the keys to a pure lowercase form with all "
"underscores converted to dashes in case of a lookup miss. For example, if a "
"request header ``My-Foo-Header`` is present, then the following invocations "
"will all pick up the value of this header correctly:"
msgstr ""

#: ../../source/modules/lua.rst:3363
msgid ""
"The ``__index`` metamethod will not be added when the ``raw`` argument is "
"set to ``true``."
msgstr ""

#: ../../source/modules/lua.rst:3367
msgid "ngx.req.set_header"
msgstr ""

#: ../../source/modules/lua.rst:3368
msgid "*ngx.req.set_header(header_name, header_value)*"
msgstr ""

#: ../../source/modules/lua.rst:3371
msgid ""
"Set the current request's request header named ``header_name`` to value "
"``header_value``, overriding any existing ones."
msgstr ""

#: ../../source/modules/lua.rst:3373
msgid ""
"By default, all the subrequests subsequently initiated by "
"`ngx.location.capture`_ and `ngx.location.capture_multi`_ will inherit the "
"new header."
msgstr ""

#: ../../source/modules/lua.rst:3375
msgid "Here is an example of setting the ``Content-Type`` header:"
msgstr ""

#: ../../source/modules/lua.rst:3381
msgid "The ``header_value`` can take an array list of values, for example,"
msgstr ""

#: ../../source/modules/lua.rst:3388
msgid "will produce two new request headers:"
msgstr ""

#: ../../source/modules/lua.rst:3395
msgid "and old ``Foo`` headers will be overridden if there is any."
msgstr ""

#: ../../source/modules/lua.rst:3397
msgid ""
"When the ``header_value`` argument is ``nil``, the request header will be "
"removed. So"
msgstr ""

#: ../../source/modules/lua.rst:3411
msgid "ngx.req.clear_header"
msgstr ""

#: ../../source/modules/lua.rst:3412
msgid "*ngx.req.clear_header(header_name)*"
msgstr ""

#: ../../source/modules/lua.rst:3415
msgid ""
"Clears the current request's request header named ``header_name``. None of "
"the current request's existing subrequests will be affected but subsequently"
" initiated subrequests will inherit the change by default."
msgstr ""

#: ../../source/modules/lua.rst:3419
msgid "ngx.req.read_body"
msgstr ""

#: ../../source/modules/lua.rst:3420
msgid "*ngx.req.read_body()*"
msgstr ""

#: ../../source/modules/lua.rst:3423
msgid ""
"Reads the client request body synchronously without blocking the Nginx event"
" loop."
msgstr ""

#: ../../source/modules/lua.rst:3430
msgid ""
"If the request body is already read previously by turning on "
"`lua_need_request_body`_ or by using other modules, then this function does "
"not run and returns immediately."
msgstr ""

#: ../../source/modules/lua.rst:3432
msgid ""
"If the request body has already been explicitly discarded, either by the "
"`ngx.req.discard_body`_ function or other modules, this function does not "
"run and returns immediately."
msgstr ""

#: ../../source/modules/lua.rst:3434
msgid ""
"In case of errors, such as connection errors while reading the data, this "
"method will throw out a Lua exception *or* terminate the current request "
"with a 500 status code immediately."
msgstr ""

#: ../../source/modules/lua.rst:3436
msgid ""
"The request body data read using this function can be retrieved later via "
"`ngx.req.get_body_data`_ or, alternatively, the temporary file name for the "
"body data cached to disk using `ngx.req.get_body_file`_. This depends on"
msgstr ""

#: ../../source/modules/lua.rst:3438
msgid ""
"whether the current request body is already larger than the "
"`client_body_buffer_size <|HttpCoreModule|#client_body_buffer_size>`_,"
msgstr ""

#: ../../source/modules/lua.rst:3439
msgid ""
"and whether `client_body_in_file_only "
"<|HttpCoreModule|#client_body_in_file_only>`_ has been switched on."
msgstr ""

#: ../../source/modules/lua.rst:3441
msgid ""
"In cases where current request may have a request body and the request body "
"data is not required, The `ngx.req.discard_body`_ function must be used to "
"explicitly discard the request body to avoid breaking things under HTTP 1.1 "
"keepalive or HTTP 1.1 pipelining."
msgstr ""

#: ../../source/modules/lua.rst:3443 ../../source/modules/lua.rst:3457
#: ../../source/modules/lua.rst:3483 ../../source/modules/lua.rst:3503
msgid "This function was first introduced in the ``v0.3.1rc17`` release."
msgstr ""

#: ../../source/modules/lua.rst:3447
msgid "ngx.req.discard_body"
msgstr ""

#: ../../source/modules/lua.rst:3448
msgid "*ngx.req.discard_body()*"
msgstr ""

#: ../../source/modules/lua.rst:3451
msgid ""
"Explicitly discard the request body, i.e., read the data on the connection "
"and throw it away immediately. Please note that ignoring request body is not"
" the right way to discard it, and that this function must be called to avoid"
" breaking things under HTTP 1.1 keepalive or HTTP 1.1 pipelining."
msgstr ""

#: ../../source/modules/lua.rst:3453
msgid "This function is an asynchronous call and returns immediately."
msgstr ""

#: ../../source/modules/lua.rst:3455
msgid ""
"If the request body has already been read, this function does nothing and "
"returns immediately."
msgstr ""

#: ../../source/modules/lua.rst:3459
msgid "`ngx.req.read_body`_."
msgstr ""

#: ../../source/modules/lua.rst:3463
msgid "ngx.req.get_body_data"
msgstr ""

#: ../../source/modules/lua.rst:3464
msgid "*data = ngx.req.get_body_data()*"
msgstr ""

#: ../../source/modules/lua.rst:3467
msgid ""
"Retrieves in-memory request body data. It returns a Lua string rather than a"
" Lua table holding all the parsed query arguments. Use the "
"`ngx.req.get_post_args`_ function instead if a Lua table is required."
msgstr ""

#: ../../source/modules/lua.rst:3469
msgid "This function returns ``nil`` if"
msgstr ""

#: ../../source/modules/lua.rst:3471
msgid "the request body has not been read,"
msgstr ""

#: ../../source/modules/lua.rst:3472
msgid "the request body has been read into disk temporary files,"
msgstr ""

#: ../../source/modules/lua.rst:3473
msgid "or the request body has zero size."
msgstr ""

#: ../../source/modules/lua.rst:3475 ../../source/modules/lua.rst:3497
msgid ""
"If the request body has not been read yet, call `ngx.req.read_body`_ first "
"(or turned on `lua_need_request_body`_ to force this module to read the "
"request body. This is not recommended however)."
msgstr ""

#: ../../source/modules/lua.rst:3477
msgid ""
"If the request body has been read into disk files, try calling the "
"`ngx.req.get_body_file`_ function instead."
msgstr ""

#: ../../source/modules/lua.rst:3479
msgid ""
"To force in-memory request bodies, try setting `client_body_buffer_size "
"<|HttpCoreModule|#client_body_buffer_size>`_ to the same size value in "
"`client_max_body_size <|HttpCoreModule|#client_max_body_size>`_."
msgstr ""

#: ../../source/modules/lua.rst:3481
msgid ""
"Note that calling this function instead of using ``ngx.var.request_body`` or"
" ``ngx.var.echo_request_body`` is more efficient because it can save one "
"dynamic memory allocation and one data copy."
msgstr ""

#: ../../source/modules/lua.rst:3485
msgid "`ngx.req.get_body_file`_."
msgstr ""

#: ../../source/modules/lua.rst:3489
msgid "ngx.req.get_body_file"
msgstr ""

#: ../../source/modules/lua.rst:3490
msgid "*file_name = ngx.req.get_body_file()*"
msgstr ""

#: ../../source/modules/lua.rst:3493
msgid ""
"Retrieves the file name for the in-file request body data. Returns ``nil`` "
"if the request body has not been read or has been read into memory."
msgstr ""

#: ../../source/modules/lua.rst:3495
msgid ""
"The returned file is read only and is usually cleaned up by Nginx's memory "
"pool. It should not be manually modified, renamed, or removed in Lua code."
msgstr ""

#: ../../source/modules/lua.rst:3499
msgid ""
"If the request body has been read into memory, try calling the "
"`ngx.req.get_body_data`_ function instead."
msgstr ""

#: ../../source/modules/lua.rst:3501
msgid ""
"To force in-file request bodies, try turning on `client_body_in_file_only "
"<|HttpCoreModule|#client_body_in_file_only>`_."
msgstr ""

#: ../../source/modules/lua.rst:3505
msgid "`ngx.req.get_body_data`_."
msgstr ""

#: ../../source/modules/lua.rst:3509
msgid "ngx.req.set_body_data"
msgstr ""

#: ../../source/modules/lua.rst:3510
msgid "*ngx.req.set_body_data(data)*"
msgstr ""

#: ../../source/modules/lua.rst:3513
msgid ""
"Set the current request's request body using the in-memory data specified by"
" the ``data`` argument."
msgstr ""

#: ../../source/modules/lua.rst:3515 ../../source/modules/lua.rst:3533
msgid ""
"If the current request's request body has not been read, then it will be "
"properly discarded. When the current request's request body has been read "
"into memory or buffered into a disk file, then the old request body's memory"
" will be freed or the disk file will be cleaned up immediately, "
"respectively."
msgstr ""

#: ../../source/modules/lua.rst:3517 ../../source/modules/lua.rst:3535
msgid "This function was first introduced in the ``v0.3.1rc18`` release."
msgstr ""

#: ../../source/modules/lua.rst:3519
msgid "`ngx.req.set_body_file`_."
msgstr ""

#: ../../source/modules/lua.rst:3523
msgid "ngx.req.set_body_file"
msgstr ""

#: ../../source/modules/lua.rst:3524
msgid "*ngx.req.set_body_file(file_name, auto_clean?)*"
msgstr ""

#: ../../source/modules/lua.rst:3527
msgid ""
"Set the current request's request body using the in-file data specified by "
"the ``file_name`` argument."
msgstr ""

#: ../../source/modules/lua.rst:3529
msgid ""
"If the optional ``auto_clean`` argument is given a ``true`` value, then this"
" file will be removed at request completion or the next time this function "
"or `ngx.req.set_body_data`_ are called in the same request. The "
"``auto_clean`` is default to ``false``."
msgstr ""

#: ../../source/modules/lua.rst:3531
msgid ""
"Please ensure that the file specified by the ``file_name`` argument exists "
"and is readable by an Nginx worker process by setting its permission "
"properly to avoid Lua exception errors."
msgstr ""

#: ../../source/modules/lua.rst:3537
msgid "`ngx.req.set_body_data`_."
msgstr ""

#: ../../source/modules/lua.rst:3541
msgid "ngx.req.init_body"
msgstr ""

#: ../../source/modules/lua.rst:3542
msgid "*ngx.req.init_body(buffer_size?)*"
msgstr ""

#: ../../source/modules/lua.rst:3543 ../../source/modules/lua.rst:3571
#: ../../source/modules/lua.rst:3589 ../../source/modules/lua.rst:3765
msgid "*set_by_lua\\*, rewrite_by_lua\\*, access_by_lua\\*, content_by_lua\\**"
msgstr ""

#: ../../source/modules/lua.rst:3545
msgid ""
"Creates a new blank request body for the current request and inializes the "
"buffer for later request body data writing via the `ngx.req.append_body`_ "
"and `ngx.req.finish_body`_ APIs."
msgstr ""

#: ../../source/modules/lua.rst:3547
msgid ""
"If the ``buffer_size`` argument is specified, then its value will be used "
"for the size of the memory buffer for body writing with "
"`ngx.req.append_body`_. If the argument is omitted, then the value specified"
" by the standard `client_body_buffer_size "
"<|HttpCoreModule|#client_body_buffer_size>`_ directive will be used instead."
msgstr ""

#: ../../source/modules/lua.rst:3549 ../../source/modules/lua.rst:3575
msgid ""
"When the data can no longer be hold in the memory buffer for the request "
"body, then the data will be flushed onto a temporary file just like the "
"standard request body reader in the Nginx core."
msgstr ""

#: ../../source/modules/lua.rst:3551
msgid ""
"It is important to always call the `ngx.req.finish_body`_ after all the data"
" has been appended onto the current request body. Also, when this function "
"is used together with `ngx.req.socket`_, it is required to call "
"`ngx.req.socket`_ *before* this function, or you will get the \"request body"
" already exists\" error message."
msgstr ""

#: ../../source/modules/lua.rst:3553
msgid "The usage of this function is often like this:"
msgstr ""

#: ../../source/modules/lua.rst:3563
msgid ""
"This function can be used with `ngx.req.append_body`_, "
"`ngx.req.finish_body`_, and `ngx.req.socket`_ to implement efficient input "
"filters in pure Lua (in the context of `rewrite_by_lua`_\\* or "
"`access_by_lua`_\\*), which can be used with other Nginx content handler or "
"upstream modules like |HttpProxyModule| and |HttpFastcgiModule|."
msgstr ""

#: ../../source/modules/lua.rst:3565 ../../source/modules/lua.rst:3581
#: ../../source/modules/lua.rst:3595
msgid "This function was first introduced in the ``v0.5.11`` release."
msgstr ""

#: ../../source/modules/lua.rst:3569
msgid "ngx.req.append_body"
msgstr ""

#: ../../source/modules/lua.rst:3570
msgid "*ngx.req.append_body(data_chunk)*"
msgstr ""

#: ../../source/modules/lua.rst:3573
msgid ""
"Append new data chunk specified by the ``data_chunk`` argument onto the "
"existing request body created by the `ngx.req.init_body`_ call."
msgstr ""

#: ../../source/modules/lua.rst:3577
msgid ""
"It is important to always call the `ngx.req.finish_body`_ after all the data"
" has been appended onto the current request body."
msgstr ""

#: ../../source/modules/lua.rst:3579
msgid ""
"This function can be used with `ngx.req.init_body`_, `ngx.req.finish_body`_,"
" and `ngx.req.socket`_ to implement efficient input filters in pure Lua (in "
"the context of `rewrite_by_lua`_\\* or `access_by_lua`_\\*), which can be "
"used with other Nginx content handler or upstream modules like "
"|HttpProxyModule| and |HttpFastcgiModule|."
msgstr ""

#: ../../source/modules/lua.rst:3583 ../../source/modules/lua.rst:3597
msgid "`ngx.req.init_body`_."
msgstr ""

#: ../../source/modules/lua.rst:3587
msgid "ngx.req.finish_body"
msgstr ""

#: ../../source/modules/lua.rst:3588
msgid "*ngx.req.finish_body()*"
msgstr ""

#: ../../source/modules/lua.rst:3591
msgid ""
"Completes the construction process of the new request body created by the "
"`ngx.req.init_body`_ and `ngx.req.append_body`_ calls."
msgstr ""

#: ../../source/modules/lua.rst:3593
msgid ""
"This function can be used with `ngx.req.init_body`_, `ngx.req.append_body`_,"
" and `ngx.req.socket`_ to implement efficient input filters in pure Lua (in "
"the context of `rewrite_by_lua`_\\* or `access_by_lua`_\\*), which can be "
"used with other Nginx content handler or upstream modules like "
"|HttpProxyModule| and |HttpFastcgiModule|."
msgstr ""

#: ../../source/modules/lua.rst:3601
msgid "ngx.req.socket"
msgstr ""

#: ../../source/modules/lua.rst:3602
msgid "*tcpsock, err = ngx.req.socket()*"
msgstr ""

#: ../../source/modules/lua.rst:3603
msgid "*tcpsock, err = ngx.req.socket(raw)*"
msgstr ""

#: ../../source/modules/lua.rst:3606
msgid ""
"Returns a read-only cosocket object that wraps the downstream connection. "
"Only `receive <tcpsock:receive_>`__ and `receiveuntil "
"<tcpsock:receiveuntil_>`_ methods are supported on this object."
msgstr ""

#: ../../source/modules/lua.rst:3608
msgid ""
"In case of error, ``nil`` will be returned as well as a string describing "
"the error."
msgstr ""

#: ../../source/modules/lua.rst:3610
msgid ""
"The socket object returned by this method is usually used to read the "
"current request's body in a streaming fashion. Do not turn on the "
"`lua_need_request_body`_ directive, and do not mix this call with "
"`ngx.req.read_body`_ and `ngx.req.discard_body`_."
msgstr ""

#: ../../source/modules/lua.rst:3612
msgid ""
"If any request body data has been pre-read into the Nginx core request "
"header buffer, the resulting cosocket object will take care of this to avoid"
" potential data loss resulting from such pre-reading. Chunked request bodies"
" are not yet supported in this API."
msgstr ""

#: ../../source/modules/lua.rst:3614
msgid ""
"Since the ``v0.9.0`` release, this function accepts an optional boolean "
"``raw`` argument. When this argument is ``true``, this function returns a "
"full-duplex cosocket object wrapping around the raw downstream connection "
"socket, upon which you can call the `receive <tcpsock:receive_>`__, "
"`receiveuntil <tcpsock:receiveuntil_>`_, and `send <tcpsock:send_>`__ "
"methods."
msgstr ""

#: ../../source/modules/lua.rst:3616
msgid ""
"When the ``raw`` argument is ``true``, it is required that no pending data "
"from any previous `ngx.say`_, `ngx.print`_, or `ngx.send_headers`_ calls "
"exists. So if you have these downstream output calls previously, you should "
"call `ngx.flush(true) <ngx.flush_>`_ before calling ``ngx.req.socket(true)``"
" to ensure that there is no pending output data. If the request body has not"
" been read yet, then this \"raw socket\" can also be used to read the "
"request body."
msgstr ""

#: ../../source/modules/lua.rst:3618
msgid ""
"You can use the \"raw request socket\" returned by ``ngx.req.socket(true)`` "
"to implement fancy protocols like `WebSocket "
"<https://en.wikipedia.org/wiki/WebSocket>`_, or just emit your own raw HTTP "
"response header or body data. You can refer to the :github:`lua-resty-"
"websocket library <openresty/lua-resty-websocket>` for a real world example."
msgstr ""

#: ../../source/modules/lua.rst:3620
msgid "This function was first introduced in the ``v0.5.0rc1`` release."
msgstr ""

#: ../../source/modules/lua.rst:3624
msgid "ngx.exec"
msgstr ""

#: ../../source/modules/lua.rst:3625
msgid "*ngx.exec(uri, args?)*"
msgstr ""

#: ../../source/modules/lua.rst:3628
msgid ""
"Does an internal redirect to ``uri`` with ``args`` and is similar to the "
"``echo_exec`` directive of the :doc:`echo module <echo>`."
msgstr ""

#: ../../source/modules/lua.rst:3636
msgid ""
"The optional second ``args`` can be used to specify extra URI query "
"arguments, for example:"
msgstr ""

#: ../../source/modules/lua.rst:3642
msgid ""
"Alternatively, a Lua table can be passed for the ``args`` argument for "
"ngx_lua to carry out URI escaping and string concatenation."
msgstr ""

#: ../../source/modules/lua.rst:3648
msgid "The result is exactly the same as the previous example."
msgstr ""

#: ../../source/modules/lua.rst:3650
msgid ""
"The format for the Lua table passed as the ``args`` argument is identical to"
" the format used in the `ngx.encode_args`_ method."
msgstr ""

#: ../../source/modules/lua.rst:3652
msgid ""
"Named locations are also supported but the second ``args`` argument will be "
"ignored if present and the querystring for the new target is inherited from "
"the referring location (if any)."
msgstr ""

#: ../../source/modules/lua.rst:3654
msgid ""
"``GET /foo/file.php?a=hello`` will return \"hello\" and not \"goodbye\" in "
"the example below"
msgstr ""

#: ../../source/modules/lua.rst:3675
msgid ""
"The ``ngx.exec`` method is different from `ngx.redirect`_ in that it is "
"purely an internal redirect and that no new external HTTP traffic is "
"involved."
msgstr ""

#: ../../source/modules/lua.rst:3677
msgid ""
"Also note that this method call terminates the processing of the current "
"request and that it *must* be called before `ngx.send_headers`_ or explicit "
"response body outputs by either `ngx.print`_ or `ngx.say`_."
msgstr ""

#: ../../source/modules/lua.rst:3679
msgid ""
"It is recommended that a coding style that combines this method call with "
"the ``return`` statement, i.e., ``return ngx.exec(...)`` be adopted when "
"this method call is used in contexts other than `header_filter_by_lua`_ to "
"reinforce the fact that the request processing is being terminated."
msgstr ""

#: ../../source/modules/lua.rst:3683
msgid "ngx.redirect"
msgstr ""

#: ../../source/modules/lua.rst:3684
msgid "*ngx.redirect(uri, status?)*"
msgstr ""

#: ../../source/modules/lua.rst:3687
msgid "Issue an ``HTTP 301`` or ``302`` redirection to ``uri``."
msgstr ""

#: ../../source/modules/lua.rst:3689
msgid ""
"The optional ``status`` parameter specifies whether ``301`` or ``302`` to be"
" used. It is ``302`` (``ngx.HTTP_MOVED_TEMPORARILY``) by default."
msgstr ""

#: ../../source/modules/lua.rst:3691
msgid ""
"Here is an example assuming the current server name is ``localhost`` and "
"that it is listening on port 1984:"
msgstr ""

#: ../../source/modules/lua.rst:3703
msgid "Redirecting arbitrary external URLs is also supported, for example:"
msgstr ""

#: ../../source/modules/lua.rst:3709
msgid ""
"We can also use the numerical code directly as the second ``status`` "
"argument:"
msgstr ""

#: ../../source/modules/lua.rst:3715
msgid ""
"This method is similar to the `rewrite <|HttpRewriteModule|#rewrite>`_ "
"directive with the ``redirect`` modifier in the standard "
"|HttpRewriteModule|, for example, this ``nginx.conf`` snippet"
msgstr ""

#: ../../source/modules/lua.rst:3721
msgid "is equivalent to the following Lua code"
msgstr ""

#: ../../source/modules/lua.rst:3727
msgid "while"
msgstr ""

#: ../../source/modules/lua.rst:3739
msgid "URI arguments can be specified as well, for example:"
msgstr ""

#: ../../source/modules/lua.rst:3745
msgid ""
"This method call terminates the processing of the current request and that "
"it *must* be called before `ngx.send_headers`_ or explicit response body "
"outputs by either `ngx.print`_ or `ngx.say`_."
msgstr ""

#: ../../source/modules/lua.rst:3747
msgid ""
"It is recommended that a coding style that combines this method call with "
"the ``return`` statement, i.e., ``return ngx.redirect(...)`` be adopted when"
" this method call is used in contexts other than `header_filter_by_lua`_ to "
"reinforce the fact that the request processing is being terminated."
msgstr ""

#: ../../source/modules/lua.rst:3751
msgid "ngx.send_headers"
msgstr ""

#: ../../source/modules/lua.rst:3752
msgid "*ok, err = ngx.send_headers()*"
msgstr ""

#: ../../source/modules/lua.rst:3755
msgid "Explicitly send out the response headers."
msgstr ""

#: ../../source/modules/lua.rst:3757 ../../source/modules/lua.rst:3779
#: ../../source/modules/lua.rst:3847 ../../source/modules/lua.rst:3926
msgid ""
"Since ``v0.8.3`` this function returns ``1`` on success, or returns ``nil`` "
"and a string describing the error otherwise."
msgstr ""

#: ../../source/modules/lua.rst:3759
msgid ""
"There is normally no need to manually send out response headers as ngx_lua "
"will automatically send headers out before content is output with `ngx.say`_"
" or `ngx.print`_ or when `content_by_lua`_ exits normally."
msgstr ""

#: ../../source/modules/lua.rst:3763
msgid "ngx.headers_sent"
msgstr ""

#: ../../source/modules/lua.rst:3764
msgid "*value = ngx.headers_sent*"
msgstr ""

#: ../../source/modules/lua.rst:3767
msgid ""
"Returns ``true`` if the response headers have been sent (by ngx_lua), and "
"``false`` otherwise."
msgstr ""

#: ../../source/modules/lua.rst:3769
msgid "This API was first introduced in ngx_lua v0.3.1rc6."
msgstr ""

#: ../../source/modules/lua.rst:3773
msgid "ngx.print"
msgstr ""

#: ../../source/modules/lua.rst:3774
msgid "*ok, err = ngx.print(...)*"
msgstr ""

#: ../../source/modules/lua.rst:3777
msgid ""
"Emits arguments concatenated to the HTTP client (as response body). If "
"response headers have not been sent, this function will send headers out "
"first and then output body data."
msgstr ""

#: ../../source/modules/lua.rst:3781
msgid ""
"Lua ``nil`` values will output ``\"nil\"`` strings and Lua boolean values "
"will output ``\"true\"`` and ``\"false\"`` literal strings respectively."
msgstr ""

#: ../../source/modules/lua.rst:3783
msgid ""
"Nested arrays of strings are permitted and the elements in the arrays will "
"be sent one by one:"
msgstr ""

#: ../../source/modules/lua.rst:3794
msgid "will yield the output"
msgstr ""

#: ../../source/modules/lua.rst:3800
msgid "Non-array table arguments will cause a Lua exception to be thrown."
msgstr ""

#: ../../source/modules/lua.rst:3802
msgid "The ``ngx.null`` constant will yield the ``\"null\"`` string output."
msgstr ""

#: ../../source/modules/lua.rst:3804
msgid ""
"This is an asynchronous call and will return immediately without waiting for"
" all the data to be written into the system send buffer. To run in "
"synchronous mode, call ``ngx.flush(true)`` after calling ``ngx.print``. This"
" can be particularly useful for streaming output. See `ngx.flush`_ for more "
"details."
msgstr ""

#: ../../source/modules/lua.rst:3806
msgid ""
"Please note that both ``ngx.print`` and `ngx.say`_ will always invoke the "
"whole Nginx output body filter chain, which is an expensive operation. So be"
" careful when calling either of these two in a tight loop; buffer the data "
"yourself in Lua and save the calls."
msgstr ""

#: ../../source/modules/lua.rst:3810
msgid "ngx.say"
msgstr ""

#: ../../source/modules/lua.rst:3811
msgid "*ok, err = ngx.say(...)*"
msgstr ""

#: ../../source/modules/lua.rst:3814
msgid "Just as `ngx.print`_ but also emit a trailing newline."
msgstr ""

#: ../../source/modules/lua.rst:3818
msgid "ngx.log"
msgstr ""

#: ../../source/modules/lua.rst:3819
msgid "*ngx.log(log_level, ...)*"
msgstr ""

#: ../../source/modules/lua.rst:3820 ../../source/modules/lua.rst:3946
#: ../../source/modules/lua.rst:3954 ../../source/modules/lua.rst:4658
#: ../../source/modules/lua.rst:5481
msgid ""
"*init_by_lua\\*, init_worker_by_lua\\*, set_by_lua\\*, rewrite_by_lua\\*, "
"access_by_lua\\*, content_by_lua\\*, header_filter_by_lua\\*, "
"body_filter_by_lua\\*, log_by_lua\\*, ngx.timer.\\**"
msgstr ""

#: ../../source/modules/lua.rst:3822
msgid "Log arguments concatenated to error.log with the given logging level."
msgstr ""

#: ../../source/modules/lua.rst:3824
msgid ""
"Lua ``nil`` arguments are accepted and result in literal ``\"nil\"`` string "
"while Lua booleans result in literal ``\"true\"`` or ``\"false\"`` string "
"outputs. And the ``ngx.null`` constant will yield the ``\"null\"`` string "
"output."
msgstr ""

#: ../../source/modules/lua.rst:3826
msgid ""
"The ``log_level`` argument can take constants like ``ngx.ERR`` and "
"``ngx.WARN``. Check out `Nginx log level constants`_ for details."
msgstr ""

#: ../../source/modules/lua.rst:3832
msgid "ngx.flush"
msgstr ""

#: ../../source/modules/lua.rst:3833
msgid "*ok, err = ngx.flush(wait?)*"
msgstr ""

#: ../../source/modules/lua.rst:3834
msgid "*false*"
msgstr ""

#: ../../source/modules/lua.rst:3837
msgid "Flushes response output to the client."
msgstr ""

#: ../../source/modules/lua.rst:3839
msgid ""
"``ngx.flush`` accepts an optional boolean ``wait`` argument first introduced"
" in the ``v0.3.1rc34`` release. When called with the default argument, it "
"issues an asynchronous call (Returns immediately without waiting for output "
"data to be written into the system send buffer). Calling the function with "
"the ``wait`` argument set to ``true`` switches to synchronous mode."
msgstr ""

#: ../../source/modules/lua.rst:3841
msgid ""
"In synchronous mode, the function will not return until all output data has "
"been written into the system send buffer or until the `send_timeout "
"<|HttpCoreModule|#send_timeout>`_ setting has expired. Note that using the "
"Lua coroutine mechanism means that this function does not block the Nginx "
"event loop even in the synchronous mode."
msgstr ""

#: ../../source/modules/lua.rst:3843
msgid ""
"When ``ngx.flush(true)`` is called immediately after `ngx.print`_ or "
"`ngx.say`_, it causes the latter functions to run in synchronous mode. This "
"can be particularly useful for streaming output."
msgstr ""

#: ../../source/modules/lua.rst:3845
msgid ""
"Note that ``ngx.flush`` is not functional when in the HTTP 1.0 output "
"buffering mode. See `HTTP 1.0 support`_."
msgstr ""

#: ../../source/modules/lua.rst:3851
msgid "ngx.exit"
msgstr ""

#: ../../source/modules/lua.rst:3852
msgid "*ngx.exit(status)*"
msgstr ""

#: ../../source/modules/lua.rst:3853
msgid ""
"*rewrite_by_lua\\*, access_by_lua\\*, content_by_lua\\*, "
"header_filter_by_lua\\*, ngx.timer.\\**"
msgstr ""

#: ../../source/modules/lua.rst:3856
msgid ""
"When ``status >= 200`` (i.e., ``ngx.HTTP_OK`` and above), it will interrupt "
"the execution of the current request and return status code to nginx."
msgstr ""

#: ../../source/modules/lua.rst:3858
msgid ""
"When ``status == 0`` (i.e., ``ngx.OK``), it will only quit the current phase"
" handler (or the content handler if the `content_by_lua`_ directive is used)"
" and continue to run later phases (if any) for the current request."
msgstr ""

#: ../../source/modules/lua.rst:3860
msgid ""
"The ``status`` argument can be ``ngx.OK``, ``ngx.ERROR``, "
"``ngx.HTTP_NOT_FOUND``, ``ngx.HTTP_MOVED_TEMPORARILY``, or other `HTTP "
"status constants`_."
msgstr ""

#: ../../source/modules/lua.rst:3862
msgid ""
"To return an error page with custom contents, use code snippets like this:"
msgstr ""

#: ../../source/modules/lua.rst:3871
msgid "The effect in action:"
msgstr ""

#: ../../source/modules/lua.rst:3885
msgid "Number literals can be used directly as the argument, for instance,"
msgstr ""

#: ../../source/modules/lua.rst:3891
msgid ""
"Note that while this method accepts all `HTTP status constants`_ as input, "
"it only accepts ``NGX_OK`` and ``NGX_ERROR`` of the `core constants`_."
msgstr ""

#: ../../source/modules/lua.rst:3893
msgid ""
"Also note that this method call terminates the processing of the current "
"request and that it is recommended that a coding style that combines this "
"method call with the ``return`` statement, i.e., ``return ngx.exit(...)`` be"
" used to reinforce the fact that the request processing is being terminated."
msgstr ""

#: ../../source/modules/lua.rst:3895
msgid ""
"When being used in the context of `header_filter_by_lua`_, ``ngx.exit()`` is"
" an asynchronous operation and will return immediately. This behavior may "
"change in future and it is recommended that users always use ``return`` in "
"combination as suggested above."
msgstr ""

#: ../../source/modules/lua.rst:3899
msgid "ngx.eof"
msgstr ""

#: ../../source/modules/lua.rst:3900
msgid "*ok, err = ngx.eof()*"
msgstr ""

#: ../../source/modules/lua.rst:3903
msgid ""
"Explicitly specify the end of the response output stream. In the case of "
"HTTP 1.1 chunked encoded output, it will just trigger the Nginx core to send"
" out the \"last chunk\"."
msgstr ""

#: ../../source/modules/lua.rst:3905
msgid ""
"When you disable the HTTP 1.1 keep-alive feature for your downstream "
"connections, you can rely on descent HTTP clients to close the connection "
"actively for you when you call this method. This trick can be used do back-"
"ground jobs without letting the HTTP clients to wait on the connection, as "
"in the following example:"
msgstr ""

#: ../../source/modules/lua.rst:3918
msgid ""
"But if you create subrequests to access other locations configured by Nginx "
"upstream modules, then you should configure those upstream modules to ignore"
" client connection abortions if they are not by default. For example, by "
"default the standard |HttpProxyModule| will terminate both the subrequest "
"and the main request as soon as the client closes the connection, so it is "
"important to turn on the `proxy_ignore_client_abort "
"<|HttpProxyModule|#proxy_ignore_client_abort>`_ directive in your location "
"block configured by |HttpProxyModule|:"
msgstr ""

#: ../../source/modules/lua.rst:3924
msgid "A better way to do background jobs is to use the `ngx.timer.at`_ API."
msgstr ""

#: ../../source/modules/lua.rst:3930
msgid "ngx.sleep"
msgstr ""

#: ../../source/modules/lua.rst:3931
msgid "*ngx.sleep(seconds)*"
msgstr ""

#: ../../source/modules/lua.rst:3932 ../../source/modules/lua.rst:4947
#: ../../source/modules/lua.rst:4968 ../../source/modules/lua.rst:5022
#: ../../source/modules/lua.rst:5036 ../../source/modules/lua.rst:5068
#: ../../source/modules/lua.rst:5080 ../../source/modules/lua.rst:5092
#: ../../source/modules/lua.rst:5130 ../../source/modules/lua.rst:5202
#: ../../source/modules/lua.rst:5220 ../../source/modules/lua.rst:5249
#: ../../source/modules/lua.rst:5288 ../../source/modules/lua.rst:5383
#: ../../source/modules/lua.rst:5397 ../../source/modules/lua.rst:5411
#: ../../source/modules/lua.rst:5421 ../../source/modules/lua.rst:5447
#: ../../source/modules/lua.rst:5460 ../../source/modules/lua.rst:5502
#: ../../source/modules/lua.rst:5637 ../../source/modules/lua.rst:5736
msgid "*rewrite_by_lua\\*, access_by_lua\\*, content_by_lua\\*, ngx.timer.\\**"
msgstr ""

#: ../../source/modules/lua.rst:3934
msgid ""
"Sleeps for the specified seconds without blocking. One can specify time "
"resolution up to 0.001 seconds (i.e., one milliseconds)."
msgstr ""

#: ../../source/modules/lua.rst:3936
msgid "Behind the scene, this method makes use of the Nginx timers."
msgstr ""

#: ../../source/modules/lua.rst:3938
msgid ""
"Since the ``0.7.20`` release, The ``0`` time argument can also be specified."
msgstr ""

#: ../../source/modules/lua.rst:3940
msgid "This method was introduced in the ``0.5.0rc30`` release."
msgstr ""

#: ../../source/modules/lua.rst:3944
msgid "ngx.escape_uri"
msgstr ""

#: ../../source/modules/lua.rst:3945
msgid "*newstr = ngx.escape_uri(str)*"
msgstr ""

#: ../../source/modules/lua.rst:3948
msgid "Escape ``str`` as a URI component."
msgstr ""

#: ../../source/modules/lua.rst:3952
msgid "ngx.unescape_uri"
msgstr ""

#: ../../source/modules/lua.rst:3953
msgid "*newstr = ngx.unescape_uri(str)*"
msgstr ""

#: ../../source/modules/lua.rst:3956
msgid "Unescape ``str`` as an escaped URI component."
msgstr ""

#: ../../source/modules/lua.rst:3958 ../../source/modules/lua.rst:3978
#: ../../source/modules/lua.rst:4099 ../../source/modules/lua.rst:4126
msgid "For example,"
msgstr ""

#: ../../source/modules/lua.rst:3964
msgid "gives the output"
msgstr ""

#: ../../source/modules/lua.rst:3972
msgid "ngx.encode_args"
msgstr ""

#: ../../source/modules/lua.rst:3973
msgid "*str = ngx.encode_args(table)*"
msgstr ""

#: ../../source/modules/lua.rst:3974 ../../source/modules/lua.rst:4027
#: ../../source/modules/lua.rst:4047 ../../source/modules/lua.rst:4057
#: ../../source/modules/lua.rst:4065 ../../source/modules/lua.rst:4079
#: ../../source/modules/lua.rst:4093 ../../source/modules/lua.rst:4122
#: ../../source/modules/lua.rst:4146 ../../source/modules/lua.rst:4156
#: ../../source/modules/lua.rst:4168 ../../source/modules/lua.rst:4727
#: ../../source/modules/lua.rst:4763
msgid ""
"*set_by_lua\\*, rewrite_by_lua\\*, access_by_lua\\*, content_by_lua\\*, "
"header_filter_by_lua\\*, body_filter_by_lua\\*, log_by_lua\\*, "
"ngx.timer.\\**"
msgstr ""

#: ../../source/modules/lua.rst:3976
msgid ""
"Encode the Lua table to a query args string according to the URI encoded "
"rules."
msgstr ""

#: ../../source/modules/lua.rst:3984 ../../source/modules/lua.rst:4012
msgid "yields"
msgstr ""

#: ../../source/modules/lua.rst:3990
msgid "The table keys must be Lua strings."
msgstr ""

#: ../../source/modules/lua.rst:3992
msgid ""
"Multi-value query args are also supported. Just use a Lua table for the "
"argument's value, for example:"
msgstr ""

#: ../../source/modules/lua.rst:3998
msgid "gives"
msgstr ""

#: ../../source/modules/lua.rst:4004
msgid ""
"If the value table is empty and the effect is equivalent to the ``nil`` "
"value."
msgstr ""

#: ../../source/modules/lua.rst:4006
msgid "Boolean argument values are also supported, for instance,"
msgstr ""

#: ../../source/modules/lua.rst:4018
msgid ""
"If the argument value is ``false``, then the effect is equivalent to the "
"``nil`` value."
msgstr ""

#: ../../source/modules/lua.rst:4021
msgid "This method was first introduced in the ``v0.3.1rc27`` release."
msgstr ""

#: ../../source/modules/lua.rst:4025
msgid "ngx.decode_args"
msgstr ""

#: ../../source/modules/lua.rst:4026
msgid "*table = ngx.decode_args(str, max_args?)*"
msgstr ""

#: ../../source/modules/lua.rst:4029
msgid ""
"Decodes a URI encoded query-string into a Lua table. This is the inverse "
"function of `ngx.encode_args`_."
msgstr ""

#: ../../source/modules/lua.rst:4031
msgid ""
"The optional ``max_args`` argument can be used to specify the maximum number"
" of arguments parsed from the ``str`` argument. By default, a maximum of 100"
" request arguments are parsed (including those with the same name) and that "
"additional URI arguments are silently discarded to guard against potential "
"denial of service attacks."
msgstr ""

#: ../../source/modules/lua.rst:4041
msgid "This method was introduced in the ``v0.5.0rc29``."
msgstr ""

#: ../../source/modules/lua.rst:4045
msgid "ngx.encode_base64"
msgstr ""

#: ../../source/modules/lua.rst:4046
msgid "*newstr = ngx.encode_base64(str, no_padding?)*"
msgstr ""

#: ../../source/modules/lua.rst:4049
msgid "Encodes ``str`` to a base64 digest."
msgstr ""

#: ../../source/modules/lua.rst:4051
msgid ""
"Since the ``0.9.16`` release, an optional boolean-typed ``no_padding`` "
"argument can be specified to control whether the base64 padding should be "
"appended to the resulting digest (default to ``false``, i.e., with padding "
"enabled). This enables streaming base64 digest calculation by (data chunks) "
"though it would be the caller's responsibility to append an appropriate "
"padding at the end of data stream."
msgstr ""

#: ../../source/modules/lua.rst:4055
msgid "ngx.decode_base64"
msgstr ""

#: ../../source/modules/lua.rst:4056
msgid "*newstr = ngx.decode_base64(str)*"
msgstr ""

#: ../../source/modules/lua.rst:4059
msgid ""
"Decodes the ``str`` argument as a base64 digest to the raw form. Returns "
"``nil`` if ``str`` is not well formed."
msgstr ""

#: ../../source/modules/lua.rst:4063
msgid "ngx.crc32_short"
msgstr ""

#: ../../source/modules/lua.rst:4064
msgid "*intval = ngx.crc32_short(str)*"
msgstr ""

#: ../../source/modules/lua.rst:4067 ../../source/modules/lua.rst:4081
msgid ""
"Calculates the CRC-32 (Cyclic Redundancy Code) digest for the ``str`` "
"argument."
msgstr ""

#: ../../source/modules/lua.rst:4069
msgid ""
"This method performs better on relatively short ``str`` inputs (i.e., less "
"than 30 ~ 60 bytes), as compared to `ngx.crc32_long`_. The result is exactly"
" the same as `ngx.crc32_long`_."
msgstr ""

#: ../../source/modules/lua.rst:4071
msgid ""
"Behind the scene, it is just a thin wrapper around the ``ngx_crc32_short`` "
"function defined in the Nginx core."
msgstr ""

#: ../../source/modules/lua.rst:4073 ../../source/modules/lua.rst:4087
msgid "This API was first introduced in the ``v0.3.1rc8`` release."
msgstr ""

#: ../../source/modules/lua.rst:4077
msgid "ngx.crc32_long"
msgstr ""

#: ../../source/modules/lua.rst:4078
msgid "*intval = ngx.crc32_long(str)*"
msgstr ""

#: ../../source/modules/lua.rst:4083
msgid ""
"This method performs better on relatively long ``str`` inputs (i.e., longer "
"than 30 ~ 60 bytes), as compared to `ngx.crc32_short`_.  The result is "
"exactly the same as `ngx.crc32_short`_."
msgstr ""

#: ../../source/modules/lua.rst:4085
msgid ""
"Behind the scene, it is just a thin wrapper around the ``ngx_crc32_long`` "
"function defined in the Nginx core."
msgstr ""

#: ../../source/modules/lua.rst:4091
msgid "ngx.hmac_sha1"
msgstr ""

#: ../../source/modules/lua.rst:4092
msgid "*digest = ngx.hmac_sha1(secret_key, str)*"
msgstr ""

#: ../../source/modules/lua.rst:4095
msgid ""
"Computes the `HMAC-SHA1 <https://en.wikipedia.org/wiki/HMAC>`_ digest of the"
" argument ``str`` and turns the result using the secret key "
"``<secret_key>``."
msgstr ""

#: ../../source/modules/lua.rst:4097
msgid ""
"The raw binary form of the ``HMAC-SHA1`` digest will be generated, use "
"`ngx.encode_base64`_, for example, to encode the result to a textual "
"representation if desired."
msgstr ""

#: ../../source/modules/lua.rst:4108 ../../source/modules/lua.rst:4134
msgid "yields the output"
msgstr ""

#: ../../source/modules/lua.rst:4114
msgid ""
"This API requires the OpenSSL library enabled in the Nginx build (usually by"
" passing the ``--with-http_ssl_module`` option to the ``./configure`` "
"script)."
msgstr ""

#: ../../source/modules/lua.rst:4116
msgid "This function was first introduced in the ``v0.3.1rc29`` release."
msgstr ""

#: ../../source/modules/lua.rst:4120
msgid "ngx.md5"
msgstr ""

#: ../../source/modules/lua.rst:4121
msgid "*digest = ngx.md5(str)*"
msgstr ""

#: ../../source/modules/lua.rst:4124
msgid ""
"Returns the hexadecimal representation of the MD5 digest of the ``str`` "
"argument."
msgstr ""

#: ../../source/modules/lua.rst:4140
msgid "See `ngx.md5_bin`_ if the raw binary MD5 digest is required."
msgstr ""

#: ../../source/modules/lua.rst:4144
msgid "ngx.md5_bin"
msgstr ""

#: ../../source/modules/lua.rst:4145
msgid "*digest = ngx.md5_bin(str)*"
msgstr ""

#: ../../source/modules/lua.rst:4148
msgid "Returns the binary form of the MD5 digest of the ``str`` argument."
msgstr ""

#: ../../source/modules/lua.rst:4150
msgid "See `ngx.md5`_ if the hexadecimal form of the MD5 digest is required."
msgstr ""

#: ../../source/modules/lua.rst:4154
msgid "ngx.sha1_bin"
msgstr ""

#: ../../source/modules/lua.rst:4155
msgid "*digest = ngx.sha1_bin(str)*"
msgstr ""

#: ../../source/modules/lua.rst:4158
msgid "Returns the binary form of the SHA-1 digest of the ``str`` argument."
msgstr ""

#: ../../source/modules/lua.rst:4160
msgid ""
"This function requires SHA-1 support in the Nginx build. (This usually just "
"means OpenSSL should be installed while building Nginx)."
msgstr ""

#: ../../source/modules/lua.rst:4162
msgid "This function was first introduced in the ``v0.5.0rc6``."
msgstr ""

#: ../../source/modules/lua.rst:4166
msgid "ngx.quote_sql_str"
msgstr ""

#: ../../source/modules/lua.rst:4167
msgid "*quoted_value = ngx.quote_sql_str(raw_value)*"
msgstr ""

#: ../../source/modules/lua.rst:4170
msgid ""
"Returns a quoted SQL string literal according to the MySQL quoting rules."
msgstr ""

#: ../../source/modules/lua.rst:4174
msgid "ngx.today"
msgstr ""

#: ../../source/modules/lua.rst:4175
msgid "*str = ngx.today()*"
msgstr ""

#: ../../source/modules/lua.rst:4176 ../../source/modules/lua.rst:4186
#: ../../source/modules/lua.rst:4196 ../../source/modules/lua.rst:4208
#: ../../source/modules/lua.rst:4218 ../../source/modules/lua.rst:4228
#: ../../source/modules/lua.rst:4238 ../../source/modules/lua.rst:4251
#: ../../source/modules/lua.rst:4264 ../../source/modules/lua.rst:4289
#: ../../source/modules/lua.rst:4439 ../../source/modules/lua.rst:4489
#: ../../source/modules/lua.rst:4563 ../../source/modules/lua.rst:4623
#: ../../source/modules/lua.rst:5785 ../../source/modules/lua.rst:5933
msgid ""
"*init_worker_by_lua\\*, set_by_lua\\*, rewrite_by_lua\\*, access_by_lua\\*, "
"content_by_lua\\*, header_filter_by_lua\\*, body_filter_by_lua\\*, "
"log_by_lua\\*, ngx.timer.\\**"
msgstr ""

#: ../../source/modules/lua.rst:4178
msgid ""
"Returns current date (in the format ``yyyy-mm-dd``) from the nginx cached "
"time (no syscall involved unlike Lua's date library)."
msgstr ""

#: ../../source/modules/lua.rst:4180 ../../source/modules/lua.rst:4222
msgid "This is the local time."
msgstr ""

#: ../../source/modules/lua.rst:4184
msgid "ngx.time"
msgstr ""

#: ../../source/modules/lua.rst:4185
msgid "*secs = ngx.time()*"
msgstr ""

#: ../../source/modules/lua.rst:4188
msgid ""
"Returns the elapsed seconds from the epoch for the current time stamp from "
"the nginx cached time (no syscall involved unlike Lua's date library)."
msgstr ""

#: ../../source/modules/lua.rst:4190
msgid ""
"Updates of the Nginx time cache an be forced by calling `ngx.update_time`_ "
"first."
msgstr ""

#: ../../source/modules/lua.rst:4194
msgid "ngx.now"
msgstr ""

#: ../../source/modules/lua.rst:4195
msgid "*secs = ngx.now()*"
msgstr ""

#: ../../source/modules/lua.rst:4198
msgid ""
"Returns a floating-point number for the elapsed time in seconds (including "
"milliseconds as the decimal part) from the epoch for the current time stamp "
"from the nginx cached time (no syscall involved unlike Lua's date library)."
msgstr ""

#: ../../source/modules/lua.rst:4200
msgid ""
"You can forcibly update the Nginx time cache by calling `ngx.update_time`_ "
"first."
msgstr ""

#: ../../source/modules/lua.rst:4202 ../../source/modules/lua.rst:4212
msgid "This API was first introduced in ``v0.3.1rc32``."
msgstr ""

#: ../../source/modules/lua.rst:4206
msgid "ngx.update_time"
msgstr ""

#: ../../source/modules/lua.rst:4207
msgid "*ngx.update_time()*"
msgstr ""

#: ../../source/modules/lua.rst:4210
msgid ""
"Forcibly updates the Nginx current time cache. This call involves a syscall "
"and thus has some overhead, so do not abuse it."
msgstr ""

#: ../../source/modules/lua.rst:4216
msgid "ngx.localtime"
msgstr ""

#: ../../source/modules/lua.rst:4217
msgid "*str = ngx.localtime()*"
msgstr ""

#: ../../source/modules/lua.rst:4220 ../../source/modules/lua.rst:4230
msgid ""
"Returns the current time stamp (in the format ``yyyy-mm-dd hh:mm:ss``) of "
"the nginx cached time (no syscall involved unlike Lua's `os.date "
"<http://www.lua.org/manual/5.1/manual.html#pdf-os.date>`_ function)."
msgstr ""

#: ../../source/modules/lua.rst:4226
msgid "ngx.utctime"
msgstr ""

#: ../../source/modules/lua.rst:4227
msgid "*str = ngx.utctime()*"
msgstr ""

#: ../../source/modules/lua.rst:4232
msgid "This is the UTC time."
msgstr ""

#: ../../source/modules/lua.rst:4236
msgid "ngx.cookie_time"
msgstr ""

#: ../../source/modules/lua.rst:4237
msgid "*str = ngx.cookie_time(sec)*"
msgstr ""

#: ../../source/modules/lua.rst:4240
msgid ""
"Returns a formatted string can be used as the cookie expiration time. The "
"parameter ``sec`` is the time stamp in seconds (like those returned from "
"`ngx.time`_)."
msgstr ""

#: ../../source/modules/lua.rst:4249
msgid "ngx.http_time"
msgstr ""

#: ../../source/modules/lua.rst:4250
msgid "*str = ngx.http_time(sec)*"
msgstr ""

#: ../../source/modules/lua.rst:4253
msgid ""
"Returns a formated string can be used as the http header time (for example, "
"being used in ``Last-Modified`` header). The parameter ``sec`` is the time "
"stamp in seconds (like those returned from `ngx.time`_)."
msgstr ""

#: ../../source/modules/lua.rst:4262
msgid "ngx.parse_http_time"
msgstr ""

#: ../../source/modules/lua.rst:4263
msgid "*sec = ngx.parse_http_time(str)*"
msgstr ""

#: ../../source/modules/lua.rst:4266
msgid ""
"Parse the http time string (as returned by `ngx.http_time`_) into seconds."
msgstr ""

#: ../../source/modules/lua.rst:4268
msgid "Returns the seconds or ``nil`` if the input string is in bad forms."
msgstr ""

#: ../../source/modules/lua.rst:4279
msgid "ngx.is_subrequest"
msgstr ""

#: ../../source/modules/lua.rst:4280
msgid "*value = ngx.is_subrequest*"
msgstr ""

#: ../../source/modules/lua.rst:4283
msgid ""
"Returns ``true`` if the current request is an nginx subrequest, or ``false``"
" otherwise."
msgstr ""

#: ../../source/modules/lua.rst:4287
msgid "ngx.re.match"
msgstr ""

#: ../../source/modules/lua.rst:4288
msgid ""
"*captures, err = ngx.re.match(subject, regex, options?, ctx?, res_table?)*"
msgstr ""

#: ../../source/modules/lua.rst:4291
msgid ""
"Matches the ``subject`` string using the Perl compatible regular expression "
"``regex`` with the optional ``options``."
msgstr ""

#: ../../source/modules/lua.rst:4293
msgid ""
"Only the first occurrence of the match is returned, or ``nil`` if no match "
"is found. In case of errors, like seeing a bad regular expression or "
"exceeding the PCRE stack limit, ``nil`` and a string describing the error "
"will be returned."
msgstr ""

#: ../../source/modules/lua.rst:4295
msgid ""
"When a match is found, a Lua table ``captures`` is returned, where "
"``captures[0]`` holds the whole substring being matched, and ``captures[1]``"
" holds the first parenthesized sub-pattern's capturing, ``captures[2]`` the "
"second, and so on."
msgstr ""

#: ../../source/modules/lua.rst:4318
msgid ""
"Named captures are also supported since the ``v0.7.14`` release and are "
"returned in the same Lua table as key-value pairs as the numbered captures."
msgstr ""

#: ../../source/modules/lua.rst:4328
msgid ""
"Unmatched subpatterns will have ``nil`` values in their ``captures`` table "
"fields."
msgstr ""

#: ../../source/modules/lua.rst:4339
msgid ""
"Specify ``options`` to control how the match operation will be performed. "
"The following option characters are supported:"
msgstr ""

#: ../../source/modules/lua.rst:4385
msgid "These options can be combined:"
msgstr ""

#: ../../source/modules/lua.rst:4399
msgid ""
"The ``o`` option is useful for performance tuning, because the regex pattern"
" in question will only be compiled once, cached in the worker-process level,"
" and shared among all requests in the current Nginx worker process. The "
"upper limit of the regex cache can be tuned via the "
"`lua_regex_cache_max_entries`_ directive."
msgstr ""

#: ../../source/modules/lua.rst:4401
msgid ""
"The optional fourth argument, ``ctx``, can be a Lua table holding an "
"optional ``pos`` field. When the ``pos`` field in the ``ctx`` table argument"
" is specified, ``ngx.re.match`` will start matching from that offset "
"(starting from 1). Regardless of the presence of the ``pos`` field in the "
"``ctx`` table, ``ngx.re.match`` will always set this ``pos`` field to the "
"position *after* the substring matched by the whole pattern in case of a "
"successful match. When match fails, the ``ctx`` table will be left intact."
msgstr ""

#: ../../source/modules/lua.rst:4417
msgid ""
"The ``ctx`` table argument combined with the ``a`` regex modifier can be "
"used to construct a lexer atop ``ngx.re.match``."
msgstr ""

#: ../../source/modules/lua.rst:4419
msgid ""
"Note that, the ``options`` argument is not optional when the ``ctx`` "
"argument is specified and that the empty Lua string (``\"\"``) must be used "
"as placeholder for ``options`` if no meaningful regex options are required."
msgstr ""

#: ../../source/modules/lua.rst:4421 ../../source/modules/lua.rst:4555
#: ../../source/modules/lua.rst:4615 ../../source/modules/lua.rst:4649
msgid ""
"This method requires the PCRE library enabled in Nginx (`Known Issue With "
"Special Escaping Sequences <Special Escaping Sequences_>`_)."
msgstr ""

#: ../../source/modules/lua.rst:4423
msgid ""
"To confirm that PCRE JIT is enabled, activate the Nginx debug log by adding "
"the ``--with-debug`` option to Nginx or ngx_openresty's ``./configure`` "
"script."
msgstr ""

#: ../../source/modules/lua.rst:4425
msgid ""
"Then, enable the \"debug\" error log level in ``error_log`` directive. The "
"following message will be generated if PCRE JIT is enabled:"
msgstr ""

#: ../../source/modules/lua.rst:4431
msgid ""
"Starting from the ``0.9.4`` release, this function also accepts a 5th "
"argument, ``res_table``, for letting the caller supply the Lua table used to"
" hold all the capturing results. Starting from ``0.9.6``, it is the caller's"
" responsibility to ensure this table is empty. This is very useful for "
"recycling Lua tables and saving GC and table allocation overhead."
msgstr ""

#: ../../source/modules/lua.rst:4433
msgid "This feature was introduced in the ``v0.2.1rc11`` release."
msgstr ""

#: ../../source/modules/lua.rst:4437
msgid "ngx.re.find"
msgstr ""

#: ../../source/modules/lua.rst:4438
msgid "*from, to, err = ngx.re.find(subject, regex, options?, ctx?, nth?)*"
msgstr ""

#: ../../source/modules/lua.rst:4441
msgid ""
"Similar to `ngx.re.match`_ but only returns the begining index (``from``) "
"and end index (``to``) of the matched substring. The returned indexes are "
"1-based and can be fed directly into the `string.sub "
"<http://www.lua.org/manual/5.1/manual.html#pdf-string.sub>`_ API function to"
" obtain the matched substring."
msgstr ""

#: ../../source/modules/lua.rst:4443
msgid ""
"In case of errors (like bad regexes or any PCRE runtime errors), this API "
"function returns two ``nil`` values followed by a string describing the "
"error."
msgstr ""

#: ../../source/modules/lua.rst:4445
msgid "If no match is found, this function just returns a ``nil`` value."
msgstr ""

#: ../../source/modules/lua.rst:4447
msgid "Below is an example:"
msgstr ""

#: ../../source/modules/lua.rst:4465
msgid "This example produces the output"
msgstr ""

#: ../../source/modules/lua.rst:4467
msgid "from: 8 to: 11 matched: 1234"
msgstr ""

#: ../../source/modules/lua.rst:4471
msgid ""
"Because this API function does not create new Lua strings nor new Lua "
"tables, it is much faster than `ngx.re.match`_. It should be used wherever "
"possible."
msgstr ""

#: ../../source/modules/lua.rst:4473
msgid ""
"Since the ``0.9.3`` release, an optional 5th argument, ``nth``, is supported"
" to specify which (submatch) capture's indexes to return. When ``nth`` is 0 "
"(which is the default), the indexes for the whole matched substring is "
"returned; when ``nth`` is 1, then the 1st submatch capture's indexes are "
"returned; when ``nth`` is 2, then the 2nd submatch capture is returned, and "
"so on. When the specified submatch does not have a match, then two ``nil`` "
"values will be returned. Below is an example for this:"
msgstr ""

#: ../../source/modules/lua.rst:4483
msgid "This API function was first introduced in the ``v0.9.2`` release."
msgstr ""

#: ../../source/modules/lua.rst:4487
msgid "ngx.re.gmatch"
msgstr ""

#: ../../source/modules/lua.rst:4488
msgid "*iterator, err = ngx.re.gmatch(subject, regex, options?)*"
msgstr ""

#: ../../source/modules/lua.rst:4491
msgid ""
"Similar to `ngx.re.match`_, but returns a Lua iterator instead, so as to let"
" the user programmer iterate all the matches over the ``<subject>`` string "
"argument with the PCRE ``regex``."
msgstr ""

#: ../../source/modules/lua.rst:4493
msgid ""
"In case of errors, like seeing an ill-formed regular expression, ``nil`` and"
" a string describing the error will be returned."
msgstr ""

#: ../../source/modules/lua.rst:4495
msgid "Here is a small example to demonstrate its basic usage:"
msgstr ""

#: ../../source/modules/lua.rst:4524
msgid "More often we just put it into a Lua loop:"
msgstr ""

#: ../../source/modules/lua.rst:4551
msgid ""
"The optional ``options`` argument takes exactly the same semantics as the "
"`ngx.re.match`_ method."
msgstr ""

#: ../../source/modules/lua.rst:4553
msgid ""
"The current implementation requires that the iterator returned should only "
"be used in a single request. That is, one should *not* assign it to a "
"variable belonging to persistent namespace like a Lua package."
msgstr ""

#: ../../source/modules/lua.rst:4557
msgid "This feature was first introduced in the ``v0.2.1rc12`` release."
msgstr ""

#: ../../source/modules/lua.rst:4561
msgid "ngx.re.sub"
msgstr ""

#: ../../source/modules/lua.rst:4562
msgid "*newstr, n, err = ngx.re.sub(subject, regex, replace, options?)*"
msgstr ""

#: ../../source/modules/lua.rst:4565
msgid ""
"Substitutes the first match of the Perl compatible regular expression "
"``regex`` on the ``subject`` argument string with the string or function "
"argument ``replace``. The optional ``options`` argument has exactly the same"
" meaning as in `ngx.re.match`_."
msgstr ""

#: ../../source/modules/lua.rst:4567
msgid ""
"This method returns the resulting new string as well as the number of "
"successful substitutions. In case of failures, like syntax errors in the "
"regular expressions or the ``<replace>`` string argument, it will return "
"``nil`` and a string describing the error."
msgstr ""

#: ../../source/modules/lua.rst:4569
msgid ""
"When the ``replace`` is a string, then it is treated as a special template "
"for string replacement. For example,"
msgstr ""

#: ../../source/modules/lua.rst:4582
msgid ""
"where ``$0`` referring to the whole substring matched by the pattern and "
"``$1`` referring to the first parenthesized capturing substring."
msgstr ""

#: ../../source/modules/lua.rst:4584
msgid ""
"Curly braces can also be used to disambiguate variable names from the "
"background string literals:"
msgstr ""

#: ../../source/modules/lua.rst:4592
msgid ""
"Literal dollar sign characters (``$``) in the ``replace`` string argument "
"can be escaped by another dollar sign, for instance,"
msgstr ""

#: ../../source/modules/lua.rst:4600
msgid ""
"Do not use backlashes to escape dollar signs; it will not work as expected."
msgstr ""

#: ../../source/modules/lua.rst:4602
msgid ""
"When the ``replace`` argument is of type \"function\", then it will be "
"invoked with the \"match table\" as the argument to generate the replace "
"string literal for substitution. The \"match table\" fed into the "
"``replace`` function is exactly the same as the return value of "
"`ngx.re.match`_. Here is an example:"
msgstr ""

#: ../../source/modules/lua.rst:4613
msgid ""
"The dollar sign characters in the return value of the ``replace`` function "
"argument are not special at all."
msgstr ""

#: ../../source/modules/lua.rst:4617
msgid "This feature was first introduced in the ``v0.2.1rc13`` release."
msgstr ""

#: ../../source/modules/lua.rst:4621
msgid "ngx.re.gsub"
msgstr ""

#: ../../source/modules/lua.rst:4622
msgid "*newstr, n, err = ngx.re.gsub(subject, regex, replace, options?)*"
msgstr ""

#: ../../source/modules/lua.rst:4625
msgid "Just like `ngx.re.sub`_, but does global substitution."
msgstr ""

#: ../../source/modules/lua.rst:4627
msgid "Here is some examples:"
msgstr ""

#: ../../source/modules/lua.rst:4651
msgid "This feature was first introduced in the ``v0.2.1rc15`` release."
msgstr ""

#: ../../source/modules/lua.rst:4655
msgid "ngx.shared.DICT"
msgstr ""

#: ../../source/modules/lua.rst:4656
msgid "*dict = ngx.shared.DICT*"
msgstr ""

#: ../../source/modules/lua.rst:4657
msgid "*dict = ngx.shared[name_var]*"
msgstr ""

#: ../../source/modules/lua.rst:4660
msgid ""
"Fetching the shm-based Lua dictionary object for the shared memory zone "
"named ``DICT`` defined by the `lua_shared_dict`_ directive."
msgstr ""

#: ../../source/modules/lua.rst:4664
msgid "The resulting object ``dict`` has the following methods:"
msgstr ""

#: ../../source/modules/lua.rst:4666
msgid "`get <ngx.shared.DICT.get_>`_"
msgstr ""

#: ../../source/modules/lua.rst:4667
msgid "`get_stale <ngx.shared.DICT.get_stale_>`__"
msgstr ""

#: ../../source/modules/lua.rst:4668
msgid "`set <ngx.shared.DICT.set_>`_"
msgstr ""

#: ../../source/modules/lua.rst:4669
msgid "`safe_set <ngx.shared.DICT.safe_set_>`__"
msgstr ""

#: ../../source/modules/lua.rst:4670
msgid "`add <ngx.shared.DICT.add_>`_"
msgstr ""

#: ../../source/modules/lua.rst:4671
msgid "`safe_add <ngx.shared.DICT.safe_add_>`__"
msgstr ""

#: ../../source/modules/lua.rst:4672
msgid "`replace <ngx.shared.DICT.replace_>`_"
msgstr ""

#: ../../source/modules/lua.rst:4673
msgid "`delete <ngx.shared.DICT.delete_>`_"
msgstr ""

#: ../../source/modules/lua.rst:4674
msgid "`incr <ngx.shared.DICT.incr_>`_"
msgstr ""

#: ../../source/modules/lua.rst:4675
msgid "`flush_all <ngx.shared.DICT.flush_all_>`__"
msgstr ""

#: ../../source/modules/lua.rst:4676
msgid "`flush_expired <ngx.shared.DICT.flush_expired_>`__"
msgstr ""

#: ../../source/modules/lua.rst:4677
msgid "`get_keys <ngx.shared.DICT.get_keys_>`__"
msgstr ""

#: ../../source/modules/lua.rst:4679
msgid "Here is an example:"
msgstr ""

#: ../../source/modules/lua.rst:4702
msgid "Let us test it:"
msgstr ""

#: ../../source/modules/lua.rst:4715
msgid ""
"The number ``8`` will be consistently output when accessing ``/get`` "
"regardless of how many Nginx workers there are because the ``dogs`` "
"dictionary resides in the shared memory and visible to *all* of the worker "
"processes."
msgstr ""

#: ../../source/modules/lua.rst:4717
msgid ""
"The shared dictionary will retain its contents through a server config "
"reload (either by sending the ``HUP`` signal to the Nginx process or by "
"using the ``-s reload`` command-line option)."
msgstr ""

#: ../../source/modules/lua.rst:4719
msgid ""
"The contents in the dictionary storage will be lost, however, when the Nginx"
" server quits."
msgstr ""

#: ../../source/modules/lua.rst:4721 ../../source/modules/lua.rst:4755
#: ../../source/modules/lua.rst:4813 ../../source/modules/lua.rst:4841
#: ../../source/modules/lua.rst:4867 ../../source/modules/lua.rst:4881
#: ../../source/modules/lua.rst:4899
msgid "This feature was first introduced in the ``v0.3.1rc22`` release."
msgstr ""

#: ../../source/modules/lua.rst:4725
msgid "ngx.shared.DICT.get"
msgstr ""

#: ../../source/modules/lua.rst:4726
msgid "*value, flags = ngx.shared.DICT:get(key)*"
msgstr ""

#: ../../source/modules/lua.rst:4729
msgid ""
"Retrieving the value in the dictionary `ngx.shared.DICT`_ for the key "
"``key``."
msgstr ""

#: ../../source/modules/lua.rst:4731
msgid ""
"If the key does not exist or has been expired, then ``nil`` will be "
"returned."
msgstr ""

#: ../../source/modules/lua.rst:4733
msgid ""
"In case of errors, ``nil`` and a string describing the error will be "
"returned."
msgstr ""

#: ../../source/modules/lua.rst:4735
msgid ""
"The value returned will have the original data type when they were inserted "
"into the dictionary, for example, Lua booleans, numbers, or strings."
msgstr ""

#: ../../source/modules/lua.rst:4737 ../../source/modules/lua.rst:4797
msgid ""
"The first argument to this method must be the dictionary object itself, for "
"example,"
msgstr ""

#: ../../source/modules/lua.rst:4744 ../../source/modules/lua.rst:4804
msgid "or use Lua's syntactic sugar for method calls:"
msgstr ""

#: ../../source/modules/lua.rst:4751 ../../source/modules/lua.rst:4811
msgid "These two forms are fundamentally equivalent."
msgstr ""

#: ../../source/modules/lua.rst:4753
msgid ""
"If the user flags is ``0`` (the default), then no flags value will be "
"returned."
msgstr ""

#: ../../source/modules/lua.rst:4757 ../../source/modules/lua.rst:4773
#: ../../source/modules/lua.rst:4817 ../../source/modules/lua.rst:4829
#: ../../source/modules/lua.rst:4843 ../../source/modules/lua.rst:4855
#: ../../source/modules/lua.rst:4869 ../../source/modules/lua.rst:4883
#: ../../source/modules/lua.rst:4901
msgid "`ngx.shared.DICT`_."
msgstr ""

#: ../../source/modules/lua.rst:4761
msgid "ngx.shared.DICT.get_stale"
msgstr ""

#: ../../source/modules/lua.rst:4762
msgid "*value, flags, stale = ngx.shared.DICT:get_stale(key)*"
msgstr ""

#: ../../source/modules/lua.rst:4765
msgid ""
"Similar to the `get <ngx.shared.DICT.get_>`_ method but returns the value "
"even if the key has already expired."
msgstr ""

#: ../../source/modules/lua.rst:4767
msgid ""
"Returns a 3rd value, ``stale``, indicating whether the key has expired or "
"not."
msgstr ""

#: ../../source/modules/lua.rst:4769
msgid ""
"Note that the value of an expired key is not guaranteed to be available so "
"one should never rely on the availability of expired items."
msgstr ""

#: ../../source/modules/lua.rst:4771
msgid "This method was first introduced in the ``0.8.6`` release."
msgstr ""

#: ../../source/modules/lua.rst:4777
msgid "ngx.shared.DICT.set"
msgstr ""

#: ../../source/modules/lua.rst:4778
msgid ""
"*success, err, forcible = ngx.shared.DICT:set(key, value, exptime?, flags?)*"
msgstr ""

#: ../../source/modules/lua.rst:4779 ../../source/modules/lua.rst:4823
#: ../../source/modules/lua.rst:4835 ../../source/modules/lua.rst:4849
#: ../../source/modules/lua.rst:4861 ../../source/modules/lua.rst:4875
#: ../../source/modules/lua.rst:4889 ../../source/modules/lua.rst:4907
#: ../../source/modules/lua.rst:4919 ../../source/modules/lua.rst:4933
msgid ""
"*init_by_lua\\*, set_by_lua\\*, rewrite_by_lua\\*, access_by_lua\\*, "
"content_by_lua\\*, header_filter_by_lua\\*, body_filter_by_lua\\*, "
"log_by_lua\\*, ngx.timer.\\**"
msgstr ""

#: ../../source/modules/lua.rst:4781
msgid ""
"Unconditionally sets a key-value pair into the shm-based dictionary "
"`ngx.shared.DICT`_. Returns three values:"
msgstr ""

#: ../../source/modules/lua.rst:4783
msgid "boolean value to indicate whether the key-value pair is stored or not."
msgstr ""

#: ../../source/modules/lua.rst:4784
msgid "textual error message, can be ``\"no memory\"``."
msgstr ""

#: ../../source/modules/lua.rst:4785
msgid ""
"a boolean value to indicate whether other valid items have been removed "
"forcibly when out of storage in the shared memory zone."
msgstr ""

#: ../../source/modules/lua.rst:4787
msgid ""
"The ``value`` argument inserted can be Lua booleans, numbers, strings, or "
"``nil``. Their value type will also be stored into the dictionary and the "
"same data type can be retrieved later via the `get <ngx.shared.DICT.get_>`_ "
"method."
msgstr ""

#: ../../source/modules/lua.rst:4789
msgid ""
"The optional ``exptime`` argument specifies expiration time (in seconds) for"
" the inserted key-value pair. The time resolution is ``0.001`` seconds. If "
"the ``exptime`` takes the value ``0`` (which is the default), then the item "
"will never be expired."
msgstr ""

#: ../../source/modules/lua.rst:4791
msgid ""
"The optional ``flags`` argument specifies a user flags value associated with"
" the entry to be stored. It can also be retrieved later with the value. The "
"user flags is stored as an unsigned 32-bit integer internally. Defaults to "
"``0``. The user flags argument was first introduced in the ``v0.5.0rc2`` "
"release."
msgstr ""

#: ../../source/modules/lua.rst:4793
msgid ""
"When it fails to allocate memory for the current key-value item, then "
"``set`` will try removing existing items in the storage according to the "
"Least-Recently Used (LRU) algorithm. Note that, LRU takes priority over "
"expiration time here. If up to tens of existing items have been removed and "
"the storage left is still insufficient (either due to the total capacity "
"limit specified by `lua_shared_dict`_ or memory segmentation), then the "
"``err`` return value will be ``no memory`` and ``success`` will be "
"``false``."
msgstr ""

#: ../../source/modules/lua.rst:4795
msgid ""
"If this method succeeds in storing the current item by forcibly removing "
"other not-yet-expired items in the dictionary via LRU, the ``forcible`` "
"return value will be ``true``. If it stores the item without forcibly "
"removing other valid items, then the return value ``forcible`` will be "
"``false``."
msgstr ""

#: ../../source/modules/lua.rst:4815
msgid ""
"Please note that while internally the key-value pair is set atomically, the "
"atomicity does not go across the method call boundary."
msgstr ""

#: ../../source/modules/lua.rst:4821
msgid "ngx.shared.DICT.safe_set"
msgstr ""

#: ../../source/modules/lua.rst:4822
msgid "*ok, err = ngx.shared.DICT:safe_set(key, value, exptime?, flags?)*"
msgstr ""

#: ../../source/modules/lua.rst:4825
msgid ""
"Similar to the `set <ngx.shared.DICT.set_>`_ method, but never overrides the"
" (least recently used) unexpired items in the store when running out of "
"storage in the shared memory zone. In this case, it will immediately return "
"``nil`` and the string \"no memory\"."
msgstr ""

#: ../../source/modules/lua.rst:4827 ../../source/modules/lua.rst:4853
msgid "This feature was first introduced in the ``v0.7.18`` release."
msgstr ""

#: ../../source/modules/lua.rst:4833
msgid "ngx.shared.DICT.add"
msgstr ""

#: ../../source/modules/lua.rst:4834
msgid ""
"*success, err, forcible = ngx.shared.DICT:add(key, value, exptime?, flags?)*"
msgstr ""

#: ../../source/modules/lua.rst:4837
msgid ""
"Just like the `set <ngx.shared.DICT.set_>`_ method, but only stores the key-"
"value pair into the dictionary `ngx.shared.DICT`_ if the key does *not* "
"exist."
msgstr ""

#: ../../source/modules/lua.rst:4839
msgid ""
"If the ``key`` argument already exists in the dictionary (and not expired "
"for sure), the ``success`` return value will be ``false`` and the ``err`` "
"return value will be ``\"exists\"``."
msgstr ""

#: ../../source/modules/lua.rst:4847
msgid "ngx.shared.DICT.safe_add"
msgstr ""

#: ../../source/modules/lua.rst:4848
msgid "*ok, err = ngx.shared.DICT:safe_add(key, value, exptime?, flags?)*"
msgstr ""

#: ../../source/modules/lua.rst:4851
msgid ""
"Similar to the `add <ngx.shared.DICT.add_>`_ method, but never overrides the"
" (least recently used) unexpired items in the store when running out of "
"storage in the shared memory zone. In this case, it will immediately return "
"``nil`` and the string \"no memory\"."
msgstr ""

#: ../../source/modules/lua.rst:4859
msgid "ngx.shared.DICT.replace"
msgstr ""

#: ../../source/modules/lua.rst:4860
msgid ""
"*success, err, forcible = ngx.shared.DICT:replace(key, value, exptime?, "
"flags?)*"
msgstr ""

#: ../../source/modules/lua.rst:4863
msgid ""
"Just like the `set <ngx.shared.DICT.set_>`_ method, but only stores the key-"
"value pair into the dictionary `ngx.shared.DICT`_ if the key *does* exist."
msgstr ""

#: ../../source/modules/lua.rst:4865
msgid ""
"If the ``key`` argument does *not* exist in the dictionary (or expired "
"already), the ``success`` return value will be ``false`` and the ``err`` "
"return value will be ``\"not found\"``."
msgstr ""

#: ../../source/modules/lua.rst:4873
msgid "ngx.shared.DICT.delete"
msgstr ""

#: ../../source/modules/lua.rst:4874
msgid "*ngx.shared.DICT:delete(key)*"
msgstr ""

#: ../../source/modules/lua.rst:4877
msgid ""
"Unconditionally removes the key-value pair from the shm-based dictionary "
"`ngx.shared.DICT`_."
msgstr ""

#: ../../source/modules/lua.rst:4879
msgid "It is equivalent to ``ngx.shared.DICT:set(key, nil)``."
msgstr ""

#: ../../source/modules/lua.rst:4887
msgid "ngx.shared.DICT.incr"
msgstr ""

#: ../../source/modules/lua.rst:4888
msgid "*newval, err = ngx.shared.DICT:incr(key, value)*"
msgstr ""

#: ../../source/modules/lua.rst:4891
msgid ""
"Increments the (numerical) value for ``key`` in the shm-based dictionary "
"`ngx.shared.DICT`_ by the step value ``value``. Returns the new resulting "
"number if the operation is successfully completed or ``nil`` and an error "
"message otherwise."
msgstr ""

#: ../../source/modules/lua.rst:4893
msgid ""
"The key must already exist in the dictionary, otherwise it will return "
"``nil`` and ``\"not found\"``."
msgstr ""

#: ../../source/modules/lua.rst:4895
msgid ""
"If the original value is not a valid Lua number in the dictionary, it will "
"return ``nil`` and ``\"not a number\"``."
msgstr ""

#: ../../source/modules/lua.rst:4897
msgid ""
"The ``value`` argument can be any valid Lua numbers, like negative numbers "
"or floating-point numbers."
msgstr ""

#: ../../source/modules/lua.rst:4905
msgid "ngx.shared.DICT.flush_all"
msgstr ""

#: ../../source/modules/lua.rst:4906
msgid "*ngx.shared.DICT:flush_all()*"
msgstr ""

#: ../../source/modules/lua.rst:4909
msgid ""
"Flushes out all the items in the dictionary. This method does not actuall "
"free up all the memory blocks in the dictionary but just marks all the "
"existing items as expired."
msgstr ""

#: ../../source/modules/lua.rst:4911
msgid "This feature was first introduced in the ``v0.5.0rc17`` release."
msgstr ""

#: ../../source/modules/lua.rst:4913
msgid "`ngx.shared.DICT.flush_expired`_ and `ngx.shared.DICT`_."
msgstr ""

#: ../../source/modules/lua.rst:4917
msgid "ngx.shared.DICT.flush_expired"
msgstr ""

#: ../../source/modules/lua.rst:4918
msgid "*flushed = ngx.shared.DICT:flush_expired(max_count?)*"
msgstr ""

#: ../../source/modules/lua.rst:4921
msgid ""
"Flushes out the expired items in the dictionary, up to the maximal number "
"specified by the optional ``max_count`` argument. When the ``max_count`` "
"argument is given ``0`` or not given at all, then it means unlimited. "
"Returns the number of items that have actually been flushed."
msgstr ""

#: ../../source/modules/lua.rst:4923
msgid ""
"Unlike the `flush_all <ngx.shared.DICT.flush_all_>`__ method, this method "
"actually free up the memory used by the expired items."
msgstr ""

#: ../../source/modules/lua.rst:4925
msgid "This feature was first introduced in the ``v0.6.3`` release."
msgstr ""

#: ../../source/modules/lua.rst:4927
msgid "`ngx.shared.DICT.flush_all`_ and `ngx.shared.DICT`_."
msgstr ""

#: ../../source/modules/lua.rst:4931
msgid "ngx.shared.DICT.get_keys"
msgstr ""

#: ../../source/modules/lua.rst:4932
msgid "*keys = ngx.shared.DICT:get_keys(max_count?)*"
msgstr ""

#: ../../source/modules/lua.rst:4935
msgid "Fetch a list of the keys from the dictionary, up to ``<max_count>``."
msgstr ""

#: ../../source/modules/lua.rst:4937
msgid ""
"By default, only the first 1024 keys (if any) are returned. When the "
"``<max_count>`` argument is given the value ``0``, then all the keys will be"
" returned even there is more than 1024 keys in the dictionary."
msgstr ""

#: ../../source/modules/lua.rst:4939
msgid "This feature was first introduced in the ``v0.7.3`` release."
msgstr ""

#: ../../source/modules/lua.rst:4941
msgid ""
"Be careful when calling this method on dictionaries with a really huge "
"number of keys. This method may lock the dictionary for quite a while and "
"block all the nginx worker processes that are trying to access the "
"dictionary."
msgstr ""

#: ../../source/modules/lua.rst:4945
msgid "ngx.socket.udp"
msgstr ""

#: ../../source/modules/lua.rst:4946
msgid "*udpsock = ngx.socket.udp()*"
msgstr ""

#: ../../source/modules/lua.rst:4949
msgid ""
"Creates and returns a UDP or datagram-oriented unix domain socket object "
"(also known as one type of the \"cosocket\" objects). The following methods "
"are supported on this object:"
msgstr ""

#: ../../source/modules/lua.rst:4951
msgid "`setpeername <udpsock:setpeername_>`_"
msgstr ""

#: ../../source/modules/lua.rst:4952
msgid "`send <udpsock:send_>`__"
msgstr ""

#: ../../source/modules/lua.rst:4953
msgid "`receive <udpsock:receive_>`__"
msgstr ""

#: ../../source/modules/lua.rst:4954
msgid "`close <udpsock:close_>`__"
msgstr ""

#: ../../source/modules/lua.rst:4955
msgid "`settimeout <udpsock:settimeout_>`__"
msgstr ""

#: ../../source/modules/lua.rst:4957
msgid ""
"It is intended to be compatible with the UDP API of the `LuaSocket "
"<http://w3.impa.br/~diego/software/luasocket/udp.html>`__ library but is "
"100% nonblocking out of the box."
msgstr ""

#: ../../source/modules/lua.rst:4959 ../../source/modules/lua.rst:5030
#: ../../source/modules/lua.rst:5062 ../../source/modules/lua.rst:5074
#: ../../source/modules/lua.rst:5086
msgid "This feature was first introduced in the ``v0.5.7`` release."
msgstr ""

#: ../../source/modules/lua.rst:4961
msgid "`ngx.socket.tcp`_."
msgstr ""

#: ../../source/modules/lua.rst:4965
msgid "udpsock:setpeername"
msgstr ""

#: ../../source/modules/lua.rst:4966
msgid "*ok, err = udpsock:setpeername(host, port)*"
msgstr ""

#: ../../source/modules/lua.rst:4967
msgid "*ok, err = udpsock:setpeername(\"unix:/path/to/unix-domain.socket\")*"
msgstr ""

#: ../../source/modules/lua.rst:4970
msgid ""
"Attempts to connect a UDP socket object to a remote server or to a datagram "
"unix domain socket file. Because the datagram protocol is actually "
"connection-less, this method does not really establish a \"connection\", but"
" only just set the name of the remote peer for subsequent read/write "
"operations."
msgstr ""

#: ../../source/modules/lua.rst:4972 ../../source/modules/lua.rst:5136
msgid ""
"Both IP addresses and domain names can be specified as the ``host`` "
"argument. In case of domain names, this method will use Nginx core's dynamic"
" resolver to parse the domain name without blocking and it is required to "
"configure the `resolver <|HttpCoreModule|#resolver>`_ directive in the "
"``nginx.conf`` file like this:"
msgstr ""

#: ../../source/modules/lua.rst:4978 ../../source/modules/lua.rst:5142
msgid ""
"If the nameserver returns multiple IP addresses for the host name, this "
"method will pick up one randomly."
msgstr ""

#: ../../source/modules/lua.rst:4980 ../../source/modules/lua.rst:5144
msgid ""
"In case of error, the method returns ``nil`` followed by a string describing"
" the error. In case of success, the method returns ``1``."
msgstr ""

#: ../../source/modules/lua.rst:4982
msgid "Here is an example for connecting to a UDP (memcached) server:"
msgstr ""

#: ../../source/modules/lua.rst:5001
msgid ""
"Since the ``v0.7.18`` release, connecting to a datagram unix domain socket "
"file is also possible on Linux:"
msgstr ""

#: ../../source/modules/lua.rst:5012
msgid ""
"assuming the datagram service is listening on the unix domain socket file "
"``/tmp/some-datagram-service.sock`` and the client socket will use the "
"\"autobind\" feature on Linux."
msgstr ""

#: ../../source/modules/lua.rst:5014 ../../source/modules/lua.rst:5188
msgid ""
"Calling this method on an already connected socket object will cause the "
"original connection to be closed first."
msgstr ""

#: ../../source/modules/lua.rst:5016
msgid "This method was first introduced in the ``v0.5.7`` release."
msgstr ""

#: ../../source/modules/lua.rst:5020
msgid "udpsock:send"
msgstr ""

#: ../../source/modules/lua.rst:5021
msgid "*ok, err = udpsock:send(data)*"
msgstr ""

#: ../../source/modules/lua.rst:5024
msgid "Sends data on the current UDP or datagram unix domain socket object."
msgstr ""

#: ../../source/modules/lua.rst:5026
msgid ""
"In case of success, it returns ``1``. Otherwise, it returns ``nil`` and a "
"string describing the error."
msgstr ""

#: ../../source/modules/lua.rst:5028 ../../source/modules/lua.rst:5228
msgid ""
"The input argument ``data`` can either be a Lua string or a (nested) Lua "
"table holding string fragments. In case of table arguments, this method will"
" copy all the string elements piece by piece to the underlying Nginx socket "
"send buffers, which is usually optimal than doing string concatenation "
"operations on the Lua land."
msgstr ""

#: ../../source/modules/lua.rst:5034
msgid "udpsock:receive"
msgstr ""

#: ../../source/modules/lua.rst:5035
msgid "*data, err = udpsock:receive(size?)*"
msgstr ""

#: ../../source/modules/lua.rst:5038
msgid ""
"Receives data from the UDP or datagram unix domain socket object with an "
"optional receive buffer size argument, ``size``."
msgstr ""

#: ../../source/modules/lua.rst:5040
msgid "This method is a synchronous operation and is 100% nonblocking."
msgstr ""

#: ../../source/modules/lua.rst:5042
msgid ""
"In case of success, it returns the data received; in case of error, it "
"returns ``nil`` with a string describing the error."
msgstr ""

#: ../../source/modules/lua.rst:5044
msgid ""
"If the ``size`` argument is specified, then this method will use this size "
"as the receive buffer size. But when this size is greater than ``8192``, "
"then ``8192`` will be used instead."
msgstr ""

#: ../../source/modules/lua.rst:5046
msgid ""
"If no argument is specified, then the maximal buffer size, ``8192`` is "
"assumed."
msgstr ""

#: ../../source/modules/lua.rst:5048
msgid ""
"Timeout for the reading operation is controlled by the "
"`lua_socket_read_timeout`_ config directive and the `settimeout "
"<udpsock:settimeout_>`__ method. And the latter takes priority. For example:"
msgstr ""

#: ../../source/modules/lua.rst:5060
msgid ""
"It is important here to call the `settimeout <udpsock:settimeout_>`__ method"
" *before* calling this method."
msgstr ""

#: ../../source/modules/lua.rst:5066
msgid "udpsock:close"
msgstr ""

#: ../../source/modules/lua.rst:5067
msgid "*ok, err = udpsock:close()*"
msgstr ""

#: ../../source/modules/lua.rst:5070
msgid ""
"Closes the current UDP or datagram unix domain socket. It returns the ``1`` "
"in case of success and returns ``nil`` with a string describing the error "
"otherwise."
msgstr ""

#: ../../source/modules/lua.rst:5072 ../../source/modules/lua.rst:5389
msgid ""
"Socket objects that have not invoked this method (and associated "
"connections) will be closed when the socket object is released by the Lua GC"
" (Garbage Collector) or the current client HTTP request finishes processing."
msgstr ""

#: ../../source/modules/lua.rst:5078
msgid "udpsock:settimeout"
msgstr ""

#: ../../source/modules/lua.rst:5079
msgid "*udpsock:settimeout(time)*"
msgstr ""

#: ../../source/modules/lua.rst:5082
msgid ""
"Set the timeout value in milliseconds for subsequent socket operations (like"
" `receive <udpsock:receive_>`__)."
msgstr ""

#: ../../source/modules/lua.rst:5084
msgid ""
"Settings done by this method takes priority over those config directives, "
"like `lua_socket_read_timeout`_."
msgstr ""

#: ../../source/modules/lua.rst:5090
msgid "ngx.socket.tcp"
msgstr ""

#: ../../source/modules/lua.rst:5091
msgid "*tcpsock = ngx.socket.tcp()*"
msgstr ""

#: ../../source/modules/lua.rst:5094
msgid ""
"Creates and returns a TCP or stream-oriented unix domain socket object (also"
" known as one type of the \"cosocket\" objects). The following methods are "
"supported on this object:"
msgstr ""

#: ../../source/modules/lua.rst:5096
msgid "`connect <tcpsock:connect_>`_"
msgstr ""

#: ../../source/modules/lua.rst:5097
msgid "`sslhandshake <tcpsock:sslhandshake_>`_"
msgstr ""

#: ../../source/modules/lua.rst:5098
msgid "`send <tcpsock:send_>`__"
msgstr ""

#: ../../source/modules/lua.rst:5099
msgid "`receive <tcpsock:receive_>`__"
msgstr ""

#: ../../source/modules/lua.rst:5100
msgid "`close <tcpsock:close_>`__"
msgstr ""

#: ../../source/modules/lua.rst:5101
msgid "`settimeout <tcpsock:settimeout_>`__"
msgstr ""

#: ../../source/modules/lua.rst:5102
msgid "`setoption <tcpsock:setoption_>`_"
msgstr ""

#: ../../source/modules/lua.rst:5103
msgid "`receiveuntil <tcpsock:receiveuntil_>`_"
msgstr ""

#: ../../source/modules/lua.rst:5104
msgid "`setkeepalive <tcpsock:setkeepalive_>`_"
msgstr ""

#: ../../source/modules/lua.rst:5105
msgid "`getreusedtimes <tcpsock:getreusedtimes_>`_"
msgstr ""

#: ../../source/modules/lua.rst:5107
msgid ""
"It is intended to be compatible with the TCP API of the `LuaSocket "
"<http://w3.impa.br/~diego/software/luasocket/tcp.html>`__ library but is "
"100% nonblocking out of the box. Also, we introduce some new APIs to provide"
" more functionalities."
msgstr ""

#: ../../source/modules/lua.rst:5110
msgid ""
"The cosocket object created by this API function has exactly the same "
"lifetime as the Lua handler creating it. So never pass the cosocket object "
"to any other Lua handler (including ngx.timer callback functions) and never "
"share the cosocket object between different NGINX requests."
msgstr ""

#: ../../source/modules/lua.rst:5112
msgid ""
"For every cosocket object's underlying connection, if you do not explicitly "
"close it (via `close <tcpsock:close_>`__) or put it back to the connection "
"pool (via `setkeepalive <tcpsock:setkeepalive_>`_), then it is automatically"
" closed when one of the following two events happens:"
msgstr ""

#: ../../source/modules/lua.rst:5114
msgid "the current request handler completes, or"
msgstr ""

#: ../../source/modules/lua.rst:5115
msgid "the Lua cosocket object value gets collected by the Lua GC."
msgstr ""

#: ../../source/modules/lua.rst:5117
msgid ""
"Fatal errors in cosocket operations always automatically close the current "
"connection (note that, read timeout error is the only error that is not "
"fatal), and if you call `close <tcpsock:close_>`__ on a closed connection, "
"you will get the \"closed\" error."
msgstr ""

#: ../../source/modules/lua.rst:5119
msgid ""
"Starting from the ``0.9.9`` release, the cosocket object here is full-"
"duplex, that is, a reader \"light thread\" and a writer \"light thread\" can"
" operate on a single cosocket object simultaneously (both \"light threads\" "
"must belong to the same Lua handler though, see reasons above). But you "
"cannot have two \"light threads\" both reading (or writing or connecting) "
"the same cosocket, otherwise you might get an error like \"socket busy "
"reading\" when calling the methods of the cosocket object."
msgstr ""

#: ../../source/modules/lua.rst:5121 ../../source/modules/lua.rst:5242
#: ../../source/modules/lua.rst:5282 ../../source/modules/lua.rst:5391
#: ../../source/modules/lua.rst:5405 ../../source/modules/lua.rst:5415
#: ../../source/modules/lua.rst:5441 ../../source/modules/lua.rst:5453
#: ../../source/modules/lua.rst:5475
msgid "This feature was first introduced in the ``v0.5.0rc1`` release."
msgstr ""

#: ../../source/modules/lua.rst:5123
msgid "`ngx.socket.udp`_."
msgstr ""

#: ../../source/modules/lua.rst:5127
msgid "tcpsock:connect"
msgstr ""

#: ../../source/modules/lua.rst:5128
msgid "*ok, err = tcpsock:connect(host, port, options_table?)*"
msgstr ""

#: ../../source/modules/lua.rst:5129
msgid ""
"*ok, err = tcpsock:connect(\"unix:/path/to/unix-domain.socket\", "
"options_table?)*"
msgstr ""

#: ../../source/modules/lua.rst:5132
msgid ""
"Attempts to connect a TCP socket object to a remote server or to a stream "
"unix domain socket file without blocking."
msgstr ""

#: ../../source/modules/lua.rst:5134
msgid ""
"Before actually resolving the host name and connecting to the remote "
"backend, this method will always look up the connection pool for matched "
"idle connections created by previous calls of this method (or the "
"`ngx.socket.connect`_ function)."
msgstr ""

#: ../../source/modules/lua.rst:5146
msgid "Here is an example for connecting to a TCP server:"
msgstr ""

#: ../../source/modules/lua.rst:5165
msgid "Connecting to a Unix Domain Socket file is also possible:"
msgstr ""

#: ../../source/modules/lua.rst:5176
msgid ""
"assuming memcached (or something else) is listening on the unix domain "
"socket file ``/tmp/memcached.sock``."
msgstr ""

#: ../../source/modules/lua.rst:5178
msgid ""
"Timeout for the connecting operation is controlled by the "
"`lua_socket_connect_timeout`_ config directive and the `settimeout "
"<tcpsock:settimeout_>`__ method. And the latter takes priority. For example:"
msgstr ""

#: ../../source/modules/lua.rst:5186 ../../source/modules/lua.rst:5238
#: ../../source/modules/lua.rst:5278
msgid ""
"It is important here to call the `settimeout <tcpsock:settimeout_>`__ method"
" *before* calling this method."
msgstr ""

#: ../../source/modules/lua.rst:5190
msgid ""
"An optional Lua table can be specified as the last argument to this method "
"to specify various connect options:"
msgstr ""

#: ../../source/modules/lua.rst:5192
msgid ""
"``pool`` specify a custom name for the connection pool being used. If "
"omitted, then the connection pool name will be generated from the string "
"template ``\"<host>:<port>\"`` or ``\"<unix-socket-path>\"``."
msgstr ""

#: ../../source/modules/lua.rst:5194
msgid ""
"The support for the options table argument was first introduced in the "
"``v0.5.7`` release."
msgstr ""

#: ../../source/modules/lua.rst:5196 ../../source/modules/lua.rst:5377
msgid "This method was first introduced in the ``v0.5.0rc1`` release."
msgstr ""

#: ../../source/modules/lua.rst:5200
msgid "tcpsock:sslhandshake"
msgstr ""

#: ../../source/modules/lua.rst:5201
msgid ""
"*session, err = tcpsock:sslhandshake(reused_session?, server_name?, "
"ssl_verify?)*"
msgstr ""

#: ../../source/modules/lua.rst:5204
msgid "Does SSL/TLS handshake on the currently established connection."
msgstr ""

#: ../../source/modules/lua.rst:5206
msgid ""
"The optional ``reused_session`` argument can take a former SSL session "
"userdata returned by a previous ``sslhandshake`` call for exactly the same "
"target. For short-lived connections, reusing SSL sessions can usually speed "
"up the handshake by one order by magnitude but it is not so useful if the "
"connection pool is enabled. This argument defaults to `nil`. If this "
"argument takes the boolean `false` value, no SSL session userdata would "
"return by this call and only a Lua boolean will be returned as the first "
"return value; otherwise the current SSL session will always be returned as "
"the first argument in case of successes."
msgstr ""

#: ../../source/modules/lua.rst:5208
msgid ""
"The optional ``server_name`` argument is used to specify the server name for"
" the new TLS extension Server Name Indication (SNI). Use of SNI can make "
"different servers share the same IP address on the server side. Also, when "
"SSL verification is enabled, this ``server_name`` argument is also used to "
"validate the server name specified in the server certificate sent from the "
"remote."
msgstr ""

#: ../../source/modules/lua.rst:5210
msgid ""
"The optional ``ssl_verify`` argument takes a Lua boolean value to control "
"whether to perform SSL verification. When set to `true`, the server "
"certificate will be verified according to the CA certificates specified by "
"the `lua_ssl_trusted_certificate`_ directive. You may also need to adjust "
"the `lua_ssl_verify_depth`_directive to control how deep we should follow "
"along the certificate chain. Also, when the ``ssl_verify`` argument is true "
"and the ``server_name`` argument is also specified, the latter will be used "
"to validate the server name in the server certificate."
msgstr ""

#: ../../source/modules/lua.rst:5212
msgid ""
"For connections that have already done SSL/TLS handshake, this method "
"returns immediately."
msgstr ""

#: ../../source/modules/lua.rst:5214
msgid "This method was first introduced in the ``v0.9.11`` release."
msgstr ""

#: ../../source/modules/lua.rst:5218
msgid "tcpsock:send"
msgstr ""

#: ../../source/modules/lua.rst:5219
msgid "*bytes, err = tcpsock:send(data)*"
msgstr ""

#: ../../source/modules/lua.rst:5222
msgid ""
"Sends data without blocking on the current TCP or Unix Domain Socket "
"connection."
msgstr ""

#: ../../source/modules/lua.rst:5224
msgid ""
"This method is a synchronous operation that will not return until *all* the "
"data has been flushed into the system socket send buffer or an error occurs."
msgstr ""

#: ../../source/modules/lua.rst:5226
msgid ""
"In case of success, it returns the total number of bytes that have been "
"sent. Otherwise, it returns ``nil`` and a string describing the error."
msgstr ""

#: ../../source/modules/lua.rst:5230
msgid ""
"Timeout for the sending operation is controlled by the "
"`lua_socket_send_timeout`_ config directive and the `settimeout "
"<tcpsock:settimeout_>`__ method. And the latter takes priority. For example:"
msgstr ""

#: ../../source/modules/lua.rst:5240
msgid ""
"In case of any connection errors, this method always automatically closes "
"the current connection."
msgstr ""

#: ../../source/modules/lua.rst:5246
msgid "tcpsock:receive"
msgstr ""

#: ../../source/modules/lua.rst:5247
msgid "*data, err, partial = tcpsock:receive(size)*"
msgstr ""

#: ../../source/modules/lua.rst:5248
msgid "*data, err, partial = tcpsock:receive(pattern?)*"
msgstr ""

#: ../../source/modules/lua.rst:5251
msgid ""
"Receives data from the connected socket according to the reading pattern or "
"size."
msgstr ""

#: ../../source/modules/lua.rst:5253
msgid ""
"This method is a synchronous operation just like the `send "
"<tcpsock:send_>`__ method and is 100% nonblocking."
msgstr ""

#: ../../source/modules/lua.rst:5255
msgid ""
"In case of success, it returns the data received; in case of error, it "
"returns ``nil`` with a string describing the error and the partial data "
"received so far."
msgstr ""

#: ../../source/modules/lua.rst:5257
msgid ""
"If a number-like argument is specified (including strings that look like "
"numbers), then it is interpreted as a size. This method will not return "
"until it reads exactly this size of data or an error occurs."
msgstr ""

#: ../../source/modules/lua.rst:5259
msgid ""
"If a non-number-like string argument is specified, then it is interpreted as"
" a \"pattern\". The following patterns are supported:"
msgstr ""

#: ../../source/modules/lua.rst:5261
msgid ""
"``'*a'``: reads from the socket until the connection is closed. No end-of-"
"line translation is performed;"
msgstr ""

#: ../../source/modules/lua.rst:5262
msgid ""
"``'*l'``: reads a line of text from the socket. The line is terminated by a "
"``Line Feed`` (LF) character (ASCII 10), optionally preceded by a ``Carriage"
" Return`` (CR) character (ASCII 13). The CR and LF characters are not "
"included in the returned line. In fact, all CR characters are ignored by the"
" pattern."
msgstr ""

#: ../../source/modules/lua.rst:5264
msgid ""
"If no argument is specified, then it is assumed to be the pattern ``'*l'``, "
"that is, the line reading pattern."
msgstr ""

#: ../../source/modules/lua.rst:5266
msgid ""
"Timeout for the reading operation is controlled by the "
"`lua_socket_read_timeout`_ config directive and the `settimeout "
"<tcpsock:settimeout_>`__ method. And the latter takes priority. For example:"
msgstr ""

#: ../../source/modules/lua.rst:5280 ../../source/modules/lua.rst:5375
msgid ""
"Since the ``v0.8.8`` release, this method no longer automatically closes the"
" current connection when the read timeout error happens. For other "
"connection errors, this method always automatically closes the connection."
msgstr ""

#: ../../source/modules/lua.rst:5286
msgid "tcpsock:receiveuntil"
msgstr ""

#: ../../source/modules/lua.rst:5287
msgid "*iterator = tcpsock:receiveuntil(pattern, options?)*"
msgstr ""

#: ../../source/modules/lua.rst:5290
msgid ""
"This method returns an iterator Lua function that can be called to read the "
"data stream until it sees the specified pattern or an error occurs."
msgstr ""

#: ../../source/modules/lua.rst:5292
msgid ""
"Here is an example for using this method to read a data stream with the "
"boundary sequence ``--abcedhb``:"
msgstr ""

#: ../../source/modules/lua.rst:5303
msgid ""
"When called without any argument, the iterator function returns the received"
" data right *before* the specified pattern string in the incoming data "
"stream."
msgstr ""

#: ../../source/modules/lua.rst:5305
msgid ""
"So for the example above, if the incoming data stream is ``'hello, world! "
"-agentzh\\r\\n--abcedhb blah blah'``, then the string ``'hello, world! "
"-agentzh'`` will be returned."
msgstr ""

#: ../../source/modules/lua.rst:5307
msgid ""
"In case of error, the iterator function will return ``nil`` along with a "
"string describing the error and the partial data bytes that have been read "
"so far."
msgstr ""

#: ../../source/modules/lua.rst:5309
msgid ""
"The iterator function can be called multiple times and can be mixed safely "
"with other cosocket method calls or other iterator function calls."
msgstr ""

#: ../../source/modules/lua.rst:5311
msgid ""
"The iterator function behaves differently (i.e., like a real iterator) when "
"it is called with a ``size`` argument. That is, it will read that ``size`` "
"of data on each invocation and will return ``nil`` at the last invocation "
"(either sees the boundary pattern or meets an error). For the last "
"successful invocation of the iterator function, the ``err`` return value "
"will be ``nil`` too. The iterator function will be reset after the last "
"successful invocation that returns ``nil`` data and ``nil`` error. Consider "
"the following example:"
msgstr ""

#: ../../source/modules/lua.rst:5331
msgid ""
"Then for the incoming data stream ``'hello, world! -agentzh\\r\\n--abcedhb "
"blah blah'``, we shall get the following output from the sample code above:"
msgstr ""

#: ../../source/modules/lua.rst:5343
msgid ""
"Note that, the actual data returned *might* be a little longer than the size"
" limit specified by the ``size`` argument when the boundary pattern has "
"ambiguity for streaming parsing. Near the boundary of the data stream, the "
"data string actually returned could also be shorter than the size limit."
msgstr ""

#: ../../source/modules/lua.rst:5345
msgid ""
"Timeout for the iterator function's reading operation is controlled by the "
"`lua_socket_read_timeout`_ config directive and the `settimeout "
"<tcpsock:settimeout_>`__ method. And the latter takes priority. For example:"
msgstr ""

#: ../../source/modules/lua.rst:5359
msgid ""
"It is important here to call the `settimeout <tcpsock:settimeout_>`__ method"
" *before* calling the iterator function (note that the ``receiveuntil`` call"
" is irrelevant here)."
msgstr ""

#: ../../source/modules/lua.rst:5361
msgid ""
"As from the ``v0.5.1`` release, this method also takes an optional "
"``options`` table argument to control the behavior. The following options "
"are supported:"
msgstr ""

#: ../../source/modules/lua.rst:5363
msgid "``inclusive``"
msgstr ""

#: ../../source/modules/lua.rst:5365
msgid ""
"The ``inclusive`` takes a boolean value to control whether to include the "
"pattern string in the returned data string. Default to ``false``. For "
"example,"
msgstr ""

#: ../../source/modules/lua.rst:5373
msgid ""
"Then for the input data stream ``\"hello world _END_ blah blah blah\"``, "
"then the example above will output ``hello world _END_``, including the "
"pattern string ``_END_`` itself."
msgstr ""

#: ../../source/modules/lua.rst:5381
msgid "tcpsock:close"
msgstr ""

#: ../../source/modules/lua.rst:5382
msgid "*ok, err = tcpsock:close()*"
msgstr ""

#: ../../source/modules/lua.rst:5385
msgid ""
"Closes the current TCP or stream unix domain socket. It returns the ``1`` in"
" case of success and returns ``nil`` with a string describing the error "
"otherwise."
msgstr ""

#: ../../source/modules/lua.rst:5387
msgid ""
"Note that there is no need to call this method on socket objects that have "
"invoked the `setkeepalive <tcpsock:setkeepalive_>`_ method because the "
"socket object is already closed (and the current connection is saved into "
"the built-in connection pool)."
msgstr ""

#: ../../source/modules/lua.rst:5395
msgid "tcpsock:settimeout"
msgstr ""

#: ../../source/modules/lua.rst:5396
msgid "*tcpsock:settimeout(time)*"
msgstr ""

#: ../../source/modules/lua.rst:5399
msgid ""
"Set the timeout value in milliseconds for subsequent socket operations "
"(`connect <tcpsock:connect_>`_, `receive <tcpsock:receive_>`__, and "
"iterators returned from `receiveuntil <tcpsock:receiveuntil_>`_)."
msgstr ""

#: ../../source/modules/lua.rst:5401
msgid ""
"Settings done by this method takes priority over those config directives, "
"i.e., `lua_socket_connect_timeout`_, `lua_socket_send_timeout`_, and "
"`lua_socket_read_timeout`_."
msgstr ""

#: ../../source/modules/lua.rst:5403
msgid ""
"Note that this method does *not* affect the `lua_socket_keepalive_timeout`_ "
"setting; the ``timeout`` argument to the `setkeepalive "
"<tcpsock:setkeepalive_>`_ method should be used for this purpose instead."
msgstr ""

#: ../../source/modules/lua.rst:5409
msgid "tcpsock:setoption"
msgstr ""

#: ../../source/modules/lua.rst:5410
msgid "*tcpsock:setoption(option, value?)*"
msgstr ""

#: ../../source/modules/lua.rst:5413
msgid ""
"This function is added for `LuaSocket "
"<http://w3.impa.br/~diego/software/luasocket/tcp.html>`__ API compatibility "
"and does nothing for now. Its functionality will be implemented in future."
msgstr ""

#: ../../source/modules/lua.rst:5419
msgid "tcpsock:setkeepalive"
msgstr ""

#: ../../source/modules/lua.rst:5420
msgid "*ok, err = tcpsock:setkeepalive(timeout?, size?)*"
msgstr ""

#: ../../source/modules/lua.rst:5423
msgid ""
"Puts the current socket's connection immediately into the cosocket built-in "
"connection pool and keep it alive until other `connect <tcpsock:connect_>`_ "
"method calls request it or the associated maximal idle timeout is expired."
msgstr ""

#: ../../source/modules/lua.rst:5425
msgid ""
"The first optional argument, ``timeout``, can be used to specify the maximal"
" idle timeout (in milliseconds) for the current connection. If omitted, the "
"default setting in the `lua_socket_keepalive_timeout`_ config directive will"
" be used. If the ``0`` value is given, then the timeout interval is "
"unlimited."
msgstr ""

#: ../../source/modules/lua.rst:5427
msgid ""
"The second optional argument, ``size``, can be used to specify the maximal "
"number of connections allowed in the connection pool for the current server "
"(i.e., the current host-port pair or the unix domain socket file path). Note"
" that the size of the connection pool cannot be changed once the pool is "
"created. When this argument is omitted, the default setting in the "
"`lua_socket_pool_size`_ config directive will be used."
msgstr ""

#: ../../source/modules/lua.rst:5431
msgid ""
"Note that the cosocket connection pool is per Nginx worker process rather "
"than per Nginx server instance, so the size limit specified here also "
"applies to every single Nginx worker process."
msgstr ""

#: ../../source/modules/lua.rst:5433
msgid ""
"Idle connections in the pool will be monitored for any exceptional events "
"like connection abortion or unexpected incoming data on the line, in which "
"cases the connection in question will be closed and removed from the pool."
msgstr ""

#: ../../source/modules/lua.rst:5435
msgid ""
"In case of success, this method returns ``1``; otherwise, it returns ``nil``"
" and a string describing the error."
msgstr ""

#: ../../source/modules/lua.rst:5437
msgid ""
"When the system receive buffer for the current connection has unread data, "
"then this method will return the \"connection in dubious state\" error "
"message (as the second return value) because the previous session has unread"
" data left behind for the next session and the connection is not safe to be "
"reused."
msgstr ""

#: ../../source/modules/lua.rst:5439
msgid ""
"This method also makes the current cosocket object enter the \"closed\" "
"state, so there is no need to manually call the `close <tcpsock:close_>`__ "
"method on it afterwards."
msgstr ""

#: ../../source/modules/lua.rst:5445
msgid "tcpsock:getreusedtimes"
msgstr ""

#: ../../source/modules/lua.rst:5446
msgid "*count, err = tcpsock:getreusedtimes()*"
msgstr ""

#: ../../source/modules/lua.rst:5449
msgid ""
"This method returns the (successfully) reused times for the current "
"connection. In case of error, it returns ``nil`` and a string describing the"
" error."
msgstr ""

#: ../../source/modules/lua.rst:5451
msgid ""
"If the current connection does not come from the built-in connection pool, "
"then this method always returns ``0``, that is, the connection has never "
"been reused (yet). If the connection comes from the connection pool, then "
"the return value is always non-zero. So this method can also be used to "
"determine if the current connection comes from the pool."
msgstr ""

#: ../../source/modules/lua.rst:5457
msgid "ngx.socket.connect"
msgstr ""

#: ../../source/modules/lua.rst:5458
msgid "*tcpsock, err = ngx.socket.connect(host, port)*"
msgstr ""

#: ../../source/modules/lua.rst:5459
msgid "*tcpsock, err = ngx.socket.connect(\"unix:/path/to/unix-domain.socket\")*"
msgstr ""

#: ../../source/modules/lua.rst:5462
msgid ""
"This function is a shortcut for combining `ngx.socket.tcp() "
"<ngx.socket.tcp_>`_ and the `connect() <tcpsock:connect_>`_ method call in a"
" single operation. It is actually implemented like this:"
msgstr ""

#: ../../source/modules/lua.rst:5473
msgid ""
"There is no way to use the `settimeout <tcpsock:settimeout_>`__ method to "
"specify connecting timeout for this method and the "
"`lua_socket_connect_timeout`_ directive must be set at configure time "
"instead."
msgstr ""

#: ../../source/modules/lua.rst:5479
msgid "ngx.get_phase"
msgstr ""

#: ../../source/modules/lua.rst:5480
msgid "*str = ngx.get_phase()*"
msgstr ""

#: ../../source/modules/lua.rst:5483
msgid "Retrieves the current running phase name. Possible return values are:"
msgstr ""

#: ../../source/modules/lua.rst:5485
msgid "for the context of `init_by_lua`_ or `init_by_lua_file`_."
msgstr ""

#: ../../source/modules/lua.rst:5486
msgid ""
"for the context of `init_worker_by_lua`_ or `init_worker_by_lua_file`_."
msgstr ""

#: ../../source/modules/lua.rst:5487
msgid "for the context of `set_by_lua`_ or `set_by_lua_file`_."
msgstr ""

#: ../../source/modules/lua.rst:5488
msgid "for the context of `rewrite_by_lua`_ or `rewrite_by_lua_file`_."
msgstr ""

#: ../../source/modules/lua.rst:5489
msgid "for the context of `access_by_lua`_ or `access_by_lua_file`_."
msgstr ""

#: ../../source/modules/lua.rst:5490
msgid "for the context of `content_by_lua`_ or `content_by_lua_file`_."
msgstr ""

#: ../../source/modules/lua.rst:5491
msgid ""
"for the context of `header_filter_by_lua`_ or `header_filter_by_lua_file`_."
msgstr ""

#: ../../source/modules/lua.rst:5492
msgid ""
"for the context of `body_filter_by_lua`_ or `body_filter_by_lua_file`_."
msgstr ""

#: ../../source/modules/lua.rst:5493
msgid "for the context of `log_by_lua`_ or `log_by_lua_file`_."
msgstr ""

#: ../../source/modules/lua.rst:5494
msgid "for the context of user callback functions for ngx.timer.at_."
msgstr ""

#: ../../source/modules/lua.rst:5496
msgid "This API was first introduced in the ``v0.5.10`` release."
msgstr ""

#: ../../source/modules/lua.rst:5500
msgid "ngx.thread.spawn"
msgstr ""

#: ../../source/modules/lua.rst:5501
msgid "*co = ngx.thread.spawn(func, arg1, arg2, ...)*"
msgstr ""

#: ../../source/modules/lua.rst:5504
msgid ""
"Spawns a new user \"light thread\" with the Lua function ``func`` as well as"
" those optional arguments ``arg1``, ``arg2``, and etc. Returns a Lua thread "
"(or Lua coroutine) object represents this \"light thread\"."
msgstr ""

#: ../../source/modules/lua.rst:5506
msgid ""
"\"Light threads\" are just a special kind of Lua coroutines that are "
"scheduled by the ngx_lua module."
msgstr ""

#: ../../source/modules/lua.rst:5508
msgid ""
"Before ``ngx.thread.spawn`` returns, the ``func`` will be called with those "
"optional arguments until it returns, aborts with an error, or gets yielded "
"due to I/O operations via the `Nginx API for Lua`_ (like "
"`tcpsock:receive`_)."
msgstr ""

#: ../../source/modules/lua.rst:5510
msgid ""
"After ``ngx.thread.spawn`` returns, the newly-created \"light thread\" will "
"keep running asynchronously usually at various I/O events."
msgstr ""

#: ../../source/modules/lua.rst:5512
msgid ""
"All the Lua code chunks running by `rewrite_by_lua`_, `access_by_lua`_, and "
"`content_by_lua`_ are in a boilerplate \"light thread\" created "
"automatically by ngx_lua. Such boilerplate \"light thread\" are also called "
"\"entry threads\"."
msgstr ""

#: ../../source/modules/lua.rst:5514
msgid ""
"By default, the corresponding Nginx handler (e.g., `rewrite_by_lua`_ "
"handler) will not terminate until"
msgstr ""

#: ../../source/modules/lua.rst:5516
msgid "both the \"entry thread\" and all the user \"light threads\" terminates,"
msgstr ""

#: ../../source/modules/lua.rst:5517
msgid ""
"a \"light thread\" (either the \"entry thread\" or a user \"light thread\" "
"aborts by calling `ngx.exit`_, `ngx.exec`_, `ngx.redirect`_, or "
"`ngx.req.set_uri(uri, true) <ngx.req.set_uri_>`__, or"
msgstr ""

#: ../../source/modules/lua.rst:5518
msgid "the \"entry thread\" terminates with a Lua error."
msgstr ""

#: ../../source/modules/lua.rst:5520
msgid ""
"When the user \"light thread\" terminates with a Lua error, however, it will"
" not abort other running \"light threads\" like the \"entry thread\" does."
msgstr ""

#: ../../source/modules/lua.rst:5522
msgid ""
"Due to the limitation in the Nginx subrequest model, it is not allowed to "
"abort a running Nginx subrequest in general. So it is also prohibited to "
"abort a running \"light thread\" that is pending on one ore more Nginx "
"subrequests. You must call `ngx.thread.wait`_ to wait for those \"light "
"thread\" to terminate before quitting the \"world\". A notable exception "
"here is that you can abort pending subrequests by calling `ngx.exit`_ with "
"and only with the status code ``ngx.ERROR`` (-1), ``408``, ``444``, or "
"``499``."
msgstr ""

#: ../../source/modules/lua.rst:5524
msgid ""
"The \"light threads\" are not scheduled in a pre-emptive way. In other "
"words, no time-slicing is performed automatically. A \"light thread\" will "
"keep running exclusively on the CPU until"
msgstr ""

#: ../../source/modules/lua.rst:5526
msgid "a (nonblocking) I/O operation cannot be completed in a single run,"
msgstr ""

#: ../../source/modules/lua.rst:5527
msgid "it calls `coroutine.yield`_ to actively give up execution, or"
msgstr ""

#: ../../source/modules/lua.rst:5528
msgid ""
"it is aborted by a Lua error or an invocation of `ngx.exit`_, `ngx.exec`_, "
"`ngx.redirect`_, or `ngx.req.set_uri(uri, true) <ngx.req.set_uri_>`__."
msgstr ""

#: ../../source/modules/lua.rst:5530
msgid ""
"For the first two cases, the \"light thread\" will usually be resumed later "
"by the ngx_lua scheduler unless a \"stop-the-world\" event happens."
msgstr ""

#: ../../source/modules/lua.rst:5532
msgid ""
"User \"light threads\" can create \"light threads\" themselves. And normal "
"user coroutines created by `coroutine.create`_ can also create \"light "
"threads\". The coroutine (be it a normal Lua coroutine or a \"light "
"thread\") that directly spawns the \"light thread\" is called the \"parent "
"coroutine\" for the \"light thread\" newly spawned."
msgstr ""

#: ../../source/modules/lua.rst:5534
msgid ""
"The \"parent coroutine\" can call `ngx.thread.wait`_ to wait on the "
"termination of its child \"light thread\"."
msgstr ""

#: ../../source/modules/lua.rst:5536
msgid ""
"You can call coroutine.status() and coroutine.yield() on the \"light "
"thread\" coroutines."
msgstr ""

#: ../../source/modules/lua.rst:5538
msgid "The status of the \"light thread\" coroutine can be \"zombie\" if"
msgstr ""

#: ../../source/modules/lua.rst:5540
msgid ""
"the current \"light thread\" already terminates (either successfully or with"
" an error),"
msgstr ""

#: ../../source/modules/lua.rst:5541
msgid "its parent coroutine is still alive, and"
msgstr ""

#: ../../source/modules/lua.rst:5542
msgid "its parent coroutine is not waiting on it with `ngx.thread.wait`_."
msgstr ""

#: ../../source/modules/lua.rst:5544
msgid ""
"The following example demonstrates the use of coroutine.yield() in the "
"\"light thread\" coroutines to do manual time-slicing:"
msgstr ""

#: ../../source/modules/lua.rst:5574
msgid "Then it will generate the output"
msgstr ""

#: ../../source/modules/lua.rst:5587
msgid ""
"\"Light threads\" are mostly useful for doing concurrent upstream requests "
"in a single Nginx request handler, kinda like a generalized version of "
"`ngx.location.capture_multi`_ that can work with all the `Nginx API for "
"Lua`_."
msgstr ""

#: ../../source/modules/lua.rst:5589
msgid ""
"The following example demonstrates parallel requests to MySQL, Memcached, "
"and upstream HTTP services in a single Lua handler, and outputting the "
"results in the order that they actually return (very much like the Facebook "
"BigPipe model):"
msgstr ""

#: ../../source/modules/lua.rst:5631 ../../source/modules/lua.rst:5730
msgid "This API was first enabled in the ``v0.7.0`` release."
msgstr ""

#: ../../source/modules/lua.rst:5635
msgid "ngx.thread.wait"
msgstr ""

#: ../../source/modules/lua.rst:5636
msgid "*ok, res1, res2, ... = ngx.thread.wait(thread1, thread2, ...)*"
msgstr ""

#: ../../source/modules/lua.rst:5639
msgid ""
"Waits on one or more child \"light threads\" and returns the results of the "
"first \"light thread\" that terminates (either successfully or with an "
"error)."
msgstr ""

#: ../../source/modules/lua.rst:5641
msgid ""
"The arguments ``thread1``, ``thread2``, and etc are the Lua thread objects "
"returned by earlier calls of `ngx.thread.spawn`_."
msgstr ""

#: ../../source/modules/lua.rst:5643
msgid ""
"The return values have exactly the same meaning as `coroutine.resume`_, that"
" is, the first value returned is a boolean value indicating whether the "
"\"light thread\" terminates successfully or not, and subsequent values "
"returned are the return values of the user Lua function that was used to "
"spawn the \"light thread\" (in case of success) or the error object (in case"
" of failure)."
msgstr ""

#: ../../source/modules/lua.rst:5645
msgid ""
"Only the direct \"parent coroutine\" can wait on its child \"light thread\","
" otherwise a Lua exception will be raised."
msgstr ""

#: ../../source/modules/lua.rst:5647
msgid ""
"The following example demonstrates the use of ``ngx.thread.wait`` and "
"`ngx.location.capture`_ to emulate `ngx.location.capture_multi`_:"
msgstr ""

#: ../../source/modules/lua.rst:5676
msgid "Here it essentially implements the \"wait all\" model."
msgstr ""

#: ../../source/modules/lua.rst:5678
msgid "And below is an example demonstrating the \"wait any\" model:"
msgstr ""

#: ../../source/modules/lua.rst:5721
msgid "And it will generate the following output:"
msgstr ""

#: ../../source/modules/lua.rst:5734
msgid "ngx.thread.kill"
msgstr ""

#: ../../source/modules/lua.rst:5735
msgid "*ok, err = ngx.thread.kill(thread)*"
msgstr ""

#: ../../source/modules/lua.rst:5738
msgid ""
"Kills a running \"light thread\" created by `ngx.thread.spawn`_. Returns a "
"true value when successful or ``nil`` and a string describing the error "
"otherwise."
msgstr ""

#: ../../source/modules/lua.rst:5740
msgid ""
"According to the current implementation, only the parent coroutine (or "
"\"light thread\") can kill a thread. Also, a running \"light thread\" with "
"pending NGINX subrequests (initiated by `ngx.location.capture`_ for example)"
" cannot be killed due to a limitation in the NGINX core."
msgstr ""

#: ../../source/modules/lua.rst:5742
msgid "This API was first enabled in the ``v0.9.9`` release."
msgstr ""

#: ../../source/modules/lua.rst:5746
msgid "ngx.on_abort"
msgstr ""

#: ../../source/modules/lua.rst:5747
msgid "*ok, err = ngx.on_abort(callback)*"
msgstr ""

#: ../../source/modules/lua.rst:5750
msgid ""
"Registers a user Lua function as the callback which gets called "
"automatically when the client closes the (downstream) connection "
"prematurely."
msgstr ""

#: ../../source/modules/lua.rst:5752
msgid ""
"Returns ``1`` if the callback is registered successfully or returns ``nil`` "
"and a string describing the error otherwise."
msgstr ""

#: ../../source/modules/lua.rst:5754
msgid ""
"All the `Nginx API for Lua`_ can be used in the callback function because "
"the function is run in a special \"light thread\", just as those \"light "
"threads\" created by `ngx.thread.spawn`_."
msgstr ""

#: ../../source/modules/lua.rst:5756
msgid ""
"The callback function can decide what to do with the client abortion event "
"all by itself. For example, it can simply ignore the event by doing nothing "
"and the current Lua request handler will continue executing without "
"interruptions. And the callback function can also decide to terminate "
"everything by calling `ngx.exit`_, for example,"
msgstr ""

#: ../../source/modules/lua.rst:5773
msgid ""
"When `lua_check_client_abort`_ is set to ``off`` (which is the default), "
"then this function call will always return the error message "
"\"lua_check_client_abort is off\"."
msgstr ""

#: ../../source/modules/lua.rst:5775
msgid ""
"According to the current implementation, this function can only be called "
"once in a single request handler; subsequent calls will return the error "
"message \"duplicate call\"."
msgstr ""

#: ../../source/modules/lua.rst:5777
msgid "This API was first introduced in the ``v0.7.4`` release."
msgstr ""

#: ../../source/modules/lua.rst:5779
msgid "`lua_check_client_abort`_."
msgstr ""

#: ../../source/modules/lua.rst:5783
msgid "ngx.timer.at"
msgstr ""

#: ../../source/modules/lua.rst:5784
msgid "*ok, err = ngx.timer.at(delay, callback, user_arg1, user_arg2, ...)*"
msgstr ""

#: ../../source/modules/lua.rst:5787
msgid ""
"Creates an Nginx timer with a user callback function as well as optional "
"user arguments."
msgstr ""

#: ../../source/modules/lua.rst:5789
msgid ""
"The first argument, ``delay``, specifies the delay for the timer, in "
"seconds. One can specify fractional seconds like ``0.001`` to mean 1 "
"millisecond here. ``0`` delay can also be specified, in which case the timer"
" will immediately expire when the current handler yields execution."
msgstr ""

#: ../../source/modules/lua.rst:5791
msgid ""
"The second argument, ``callback``, can be any Lua function, which will be "
"invoked later in a background \"light thread\" after the delay specified. "
"The user callback will be called automatically by the Nginx core with the "
"arguments ``premature``, ``user_arg1``, ``user_arg2``, and etc, where the "
"``premature`` argument takes a boolean value indicating whether it is a "
"premature timer expiration or not, and ``user_arg1``, ``user_arg2``, and "
"etc, are those (extra) user arguments specified when calling "
"``ngx.timer.at`` as the remaining arguments."
msgstr ""

#: ../../source/modules/lua.rst:5793
msgid ""
"Premature timer expiration happens when the Nginx worker process is trying "
"to shut down, as in an Nginx configuration reload triggered by the ``HUP`` "
"signal or in an Nginx server shutdown. When the Nginx worker is trying to "
"shut down, one can no longer call ``ngx.timer.at`` to create new timers with"
" nonzero delays and in that case ``ngx.timer.at`` will return ``nil`` and a "
"string describing the error, that is, \"process exiting\"."
msgstr ""

#: ../../source/modules/lua.rst:5795
msgid ""
"Starting from the ``v0.9.3`` release, it is allowed to create zero-delay "
"timers even when the Nginx worker process starts shutting down."
msgstr ""

#: ../../source/modules/lua.rst:5797
msgid ""
"When a timer expires, the user Lua code in the timer callback is running in "
"a \"light thread\" detached completely from the original request creating "
"the timer. So objects with the same lifetime as the request creating them, "
"like `cosockets <ngx.socket.tcp_>`_, cannot be shared between the original "
"request and the timer user callback function."
msgstr ""

#: ../../source/modules/lua.rst:5799
msgid "Here is a simple example:"
msgstr ""

#: ../../source/modules/lua.rst:5822
msgid ""
"One can also create infinite re-occuring timers, for instance, a timer "
"getting triggered every ``5`` seconds, by calling ``ngx.timer.at`` "
"recursively in the timer callback function. Here is such an example,"
msgstr ""

#: ../../source/modules/lua.rst:5847
msgid ""
"Because timer callbacks run in the background and their running time will "
"not add to any client request's response time, they can easily accumulate in"
" the server and exhaust system resources due to either Lua programming "
"mistakes or just too much client traffic. To prevent extreme consequences "
"like crashing the Nginx server, there are built-in limitations on both the "
"number of \"pending timers\" and the number of \"running timers\" in an "
"Nginx worker process. The \"pending timers\" here mean timers that have not "
"yet been expired and \"running timers\" are those whose user callbacks are "
"currently running."
msgstr ""

#: ../../source/modules/lua.rst:5849
msgid ""
"The maximal number of pending timers allowed in an Nginx worker is "
"constrolled by the `lua_max_pending_timers`_ directive. The maximal number "
"of running timers is controlled by the `lua_max_running_timers`_ directive."
msgstr ""

#: ../../source/modules/lua.rst:5851
msgid ""
"According to the current implementation, each \"running timer\" will take "
"one (fake) connection record from the global connection record list "
"configured by the standard [[EventsModule#worker_connections]] directive in "
"``nginx.conf``. So ensure that the [[EventsModule#worker_connections]] "
"directive is set to a large enough value that takes into account both the "
"real connections and fake connections required by timer callbacks (as "
"limited by the `lua_max_running_timers`_ directive)."
msgstr ""

#: ../../source/modules/lua.rst:5853
msgid ""
"A lot of the Lua APIs for Nginx are enabled in the context of the timer "
"callbacks, like stream/datagram cosockets (`ngx.socket.tcp`_ and "
"`ngx.socket.udp`_), shared memory dictionaries (`ngx.shared.DICT`_), user "
"coroutines (`coroutine.* <coroutine.create_>`_), user \"light threads\" "
"(`ngx.thread.* <ngx.thread.spawn_>`_), `ngx.exit`_, `ngx.now`_/`ngx.time`_, "
"`ngx.md5`_/`ngx.sha1_bin`_, are all allowed. But the subrequest API (like "
"`ngx.location.capture`_), the `ngx.req.* <ngx.req.start_time_>`__ API, the "
"downstream output API (like `ngx.say`_, `ngx.print`_, and `ngx.flush`_) are "
"explicitly disabled in this context."
msgstr ""

#: ../../source/modules/lua.rst:5855
msgid ""
"You can pass most of the standard Lua values (nils, booleans, numbers, "
"strings, tables, closures, file handles, and etc) into the timer callback, "
"either explicitly as user arguments or implicitly as upvalues for the "
"callback closure. There are several exceptions, however: you *cannot* pass "
"any thread objects returned by `coroutine.create`_ and `ngx.thread.spawn`_ "
"or any cosocket objects returned by `ngx.socket.tcp`_, `ngx.socket.udp`_, "
"and `ngx.req.socket`_ because these objects' lifetime is bound to the "
"request context creating them while the timer callback is detached from the "
"creating request's context (by design) and runs in its own (fake) request "
"context. If you try to share the thread or cosocket objects across the "
"boundary of the creating request, then you will get the \"no co ctx found\" "
"error (for threads) or \"bad request\" (for cosockets). It is fine, however,"
" to create all these objects inside your timer callback."
msgstr ""

#: ../../source/modules/lua.rst:5857
msgid "This API was first introduced in the ``v0.8.0`` release."
msgstr ""

#: ../../source/modules/lua.rst:5861
msgid "ngx.config.debug"
msgstr ""

#: ../../source/modules/lua.rst:5862
msgid "*debug = ngx.config.debug*"
msgstr ""

#: ../../source/modules/lua.rst:5863 ../../source/modules/lua.rst:5873
#: ../../source/modules/lua.rst:5883 ../../source/modules/lua.rst:5913
#: ../../source/modules/lua.rst:5923
msgid ""
"*set_by_lua\\*, rewrite_by_lua\\*, access_by_lua\\*, content_by_lua\\*, "
"header_filter_by_lua\\*, body_filter_by_lua\\*, log_by_lua\\*, "
"ngx.timer.\\*, init_by_lua\\*, init_worker_by_lua\\**"
msgstr ""

#: ../../source/modules/lua.rst:5865
msgid ""
"This boolean field indicates whether the current Nginx is a debug build, "
"i.e., being built by the ``./configure`` option ``--with-debug``."
msgstr ""

#: ../../source/modules/lua.rst:5867
msgid "This field was first introduced in the ``0.8.7``."
msgstr ""

#: ../../source/modules/lua.rst:5871
msgid "ngx.config.prefix"
msgstr ""

#: ../../source/modules/lua.rst:5872
msgid "*prefix = ngx.config.prefix()*"
msgstr ""

#: ../../source/modules/lua.rst:5875
msgid ""
"Returns the Nginx server \"prefix\" path, as determined by the ``-p`` "
"command-line option when running the nginx executable, or the path specified"
" by the ``--prefix`` command-line option when building Nginx with the "
"``./configure`` script."
msgstr ""

#: ../../source/modules/lua.rst:5877
msgid "This function was first introduced in the ``0.9.2``."
msgstr ""

#: ../../source/modules/lua.rst:5881
msgid "ngx.config.nginx_version"
msgstr ""

#: ../../source/modules/lua.rst:5882
msgid "*ver = ngx.config.nginx_version*"
msgstr ""

#: ../../source/modules/lua.rst:5885
msgid ""
"This field take an integral value indicating the version number of the "
"current Nginx core being used. For example, the version number ``1.4.3`` "
"results in the Lua number 1004003."
msgstr ""

#: ../../source/modules/lua.rst:5887 ../../source/modules/lua.rst:5907
#: ../../source/modules/lua.rst:5917
msgid "This API was first introduced in the ``0.9.3`` release."
msgstr ""

#: ../../source/modules/lua.rst:5891
msgid "ngx.config.nginx_configure"
msgstr ""

#: ../../source/modules/lua.rst:5892
msgid "*str = ngx.config.nginx_configure()*"
msgstr ""

#: ../../source/modules/lua.rst:5893 ../../source/modules/lua.rst:5903
msgid ""
"*set_by_lua\\*, rewrite_by_lua\\*, access_by_lua\\*, content_by_lua\\*, "
"header_filter_by_lua\\*, body_filter_by_lua\\*, log_by_lua\\*, "
"ngx.timer.\\*, init_by_lua\\**"
msgstr ""

#: ../../source/modules/lua.rst:5895
msgid ""
"This function returns a string for the NGINX ``./configure`` command's "
"arguments string."
msgstr ""

#: ../../source/modules/lua.rst:5897 ../../source/modules/lua.rst:5927
msgid "This API was first introduced in the ``0.9.5`` release."
msgstr ""

#: ../../source/modules/lua.rst:5901
msgid "ngx.config.ngx_lua_version"
msgstr ""

#: ../../source/modules/lua.rst:5902
msgid "*ver = ngx.config.ngx_lua_version*"
msgstr ""

#: ../../source/modules/lua.rst:5905
msgid ""
"This field take an integral value indicating the version number of the "
"current ``ngx_lua`` module being used. For example, the version number "
"``0.9.3`` results in the Lua number 9003."
msgstr ""

#: ../../source/modules/lua.rst:5911
msgid "ngx.worker.exiting"
msgstr ""

#: ../../source/modules/lua.rst:5912
msgid "*exiting = ngx.worker.exiting()*"
msgstr ""

#: ../../source/modules/lua.rst:5915
msgid ""
"This function returns a boolean value indicating whether the current Nginx "
"worker process already starts exiting. Nginx worker process exiting happens "
"on Nginx server quit or configuration reload (aka HUP reload)."
msgstr ""

#: ../../source/modules/lua.rst:5921
msgid "ngx.worker.pid"
msgstr ""

#: ../../source/modules/lua.rst:5922
msgid "*pid = ngx.worker.pid()*"
msgstr ""

#: ../../source/modules/lua.rst:5925
msgid ""
"This function returns a Lua number for the process ID (PID) of the current "
"Nginx worker process. This API is more efficient than ``ngx.var.pid`` and "
"can be used in contexts where the `ngx.var.VARIABLE`_ API cannot be used "
"(like `init_worker_by_lua`_)."
msgstr ""

#: ../../source/modules/lua.rst:5931
msgid "ndk.set_var.DIRECTIVE"
msgstr ""

#: ../../source/modules/lua.rst:5932
msgid "*res = ndk.set_var.DIRECTIVE_NAME*"
msgstr ""

#: ../../source/modules/lua.rst:5935
msgid ""
"This mechanism allows calling other nginx C modules' directives that are "
"implemented by :github:`Nginx Devel Kit (NDK) <simpl/ngx_devel_kit>`'s "
"set_var submodule's ``ndk_set_var_value``."
msgstr ""

#: ../../source/modules/lua.rst:5937
msgid ""
"For example, the following :doc:`set_misc` directives can be invoked this "
"way:"
msgstr ""

#: ../../source/modules/lua.rst:5956
msgid "For instance,"
msgstr ""

#: ../../source/modules/lua.rst:5963
msgid ""
"Similarly, the following directives provided by "
":github:`HttpEncryptedSessionModule <openresty/encrypted-session-nginx-"
"module>` can be invoked from within Lua too:"
msgstr ""

#: ../../source/modules/lua.rst:5965
msgid "[[set_encrypt_session]]"
msgstr ""

#: ../../source/modules/lua.rst:5966
msgid "[[set_decrypt_session]]"
msgstr ""

#: ../../source/modules/lua.rst:5968
msgid ""
"This feature requires the :github:`ngx_devel_kit <simpl/ngx_devel_kit>` "
"module."
msgstr ""

#: ../../source/modules/lua.rst:5972
msgid "coroutine.create"
msgstr ""

#: ../../source/modules/lua.rst:5973
msgid "*co = coroutine.create(f)*"
msgstr ""

#: ../../source/modules/lua.rst:5974 ../../source/modules/lua.rst:5988
#: ../../source/modules/lua.rst:6002 ../../source/modules/lua.rst:6016
#: ../../source/modules/lua.rst:6028 ../../source/modules/lua.rst:6040
msgid ""
"*rewrite_by_lua\\*, access_by_lua\\*, content_by_lua\\*, init_by_lua\\*, "
"ngx.timer.\\*, header_filter_by_lua\\*, body_filter_by_lua\\**"
msgstr ""

#: ../../source/modules/lua.rst:5976
msgid ""
"Creates a user Lua coroutines with a Lua function, and returns a coroutine "
"object."
msgstr ""

#: ../../source/modules/lua.rst:5978
msgid ""
"Similar to the standard Lua `coroutine.create "
"<http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create>`_ API, but "
"works in the context of the Lua coroutines created by ngx_lua."
msgstr ""

#: ../../source/modules/lua.rst:5980 ../../source/modules/lua.rst:5994
#: ../../source/modules/lua.rst:6008 ../../source/modules/lua.rst:6020
#: ../../source/modules/lua.rst:6032 ../../source/modules/lua.rst:6044
msgid ""
"This API was first usable in the context of `init_by_lua`_ since the "
"``0.9.2``."
msgstr ""

#: ../../source/modules/lua.rst:5982 ../../source/modules/lua.rst:5996
#: ../../source/modules/lua.rst:6010 ../../source/modules/lua.rst:6022
msgid "This API was first introduced in the ``v0.6.0`` release."
msgstr ""

#: ../../source/modules/lua.rst:5986
msgid "coroutine.resume"
msgstr ""

#: ../../source/modules/lua.rst:5987
msgid "*ok, ... = coroutine.resume(co, ...)*"
msgstr ""

#: ../../source/modules/lua.rst:5990
msgid ""
"Resumes the executation of a user Lua coroutine object previously yielded or"
" just created."
msgstr ""

#: ../../source/modules/lua.rst:5992
msgid ""
"Similar to the standard Lua `coroutine.resume "
"<http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume>`_ API, but "
"works in the context of the Lua coroutines created by ngx_lua."
msgstr ""

#: ../../source/modules/lua.rst:6000
msgid "coroutine.yield"
msgstr ""

#: ../../source/modules/lua.rst:6001
msgid "*... = coroutine.yield(...)*"
msgstr ""

#: ../../source/modules/lua.rst:6004
msgid "Yields the executation of the current user Lua coroutine."
msgstr ""

#: ../../source/modules/lua.rst:6006
msgid ""
"Similar to the standard Lua `coroutine.yield "
"<http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield>`_ API, but "
"works in the context of the Lua coroutines created by ngx_lua."
msgstr ""

#: ../../source/modules/lua.rst:6014
msgid "coroutine.wrap"
msgstr ""

#: ../../source/modules/lua.rst:6015
msgid "*co = coroutine.wrap(f)*"
msgstr ""

#: ../../source/modules/lua.rst:6018
msgid ""
"Similar to the standard Lua `coroutine.wrap "
"<http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap>`_ API, but "
"works in the context of the Lua coroutines created by ngx_lua."
msgstr ""

#: ../../source/modules/lua.rst:6026
msgid "coroutine.running"
msgstr ""

#: ../../source/modules/lua.rst:6027
msgid "*co = coroutine.running()*"
msgstr ""

#: ../../source/modules/lua.rst:6030
msgid ""
"Identical to the standard Lua `coroutine.running "
"<http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.running>`_ API."
msgstr ""

#: ../../source/modules/lua.rst:6034 ../../source/modules/lua.rst:6046
msgid "This API was first enabled in the ``v0.6.0`` release."
msgstr ""

#: ../../source/modules/lua.rst:6038
msgid "coroutine.status"
msgstr ""

#: ../../source/modules/lua.rst:6039
msgid "*status = coroutine.status(co)*"
msgstr ""

#: ../../source/modules/lua.rst:6042
msgid ""
"Identical to the standard Lua `coroutine.status "
"<http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.status>`_ API."
msgstr ""

#: ../../source/modules/lua.rst:6051
msgid "Obsolete Sections"
msgstr ""

#: ../../source/modules/lua.rst:6052
msgid ""
"This section is just holding obsolete documentation sections that have been "
"either renamed or removed so that existing links over the web are still "
"valid."
msgstr ""

#: ../../source/modules/lua.rst:6056
msgid "Special PCRE Sequences"
msgstr ""

#: ../../source/modules/lua.rst:6057
msgid "This section has been renamed to `Special Escaping Sequences`_."
msgstr ""
